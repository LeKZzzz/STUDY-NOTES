

#	数据结构

---

> 数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成，即设计数据以何种方式**组织**(逻辑层面)并**存储**(物理层面)在计算机中

1. 逻辑结构
   - 集合
   - 线性结构
   - 非线性结构
      - 树结构
      - 图结构
2. 存储结构
   - 顺序存储
   - 链式存储
3. 抽象数据类型(需要通过固有数据类型实现)
   1. 数据对象
   2. 数据关系
   3. 基本操作



#	算法

---

##	时间复杂度





##	空间复杂度





#	排序

##	冒泡排序

```python

```



##	选择排序

```python
def sort(list):
    for i in range(len(list) - 1):
        min = i
        for j in range(i + 1, len(list)):
            if list[j] < list[min]:
                min = j
        t = list[i]
        list[i] = list[min]
        list[min] = t
```



##	插入排序

```C++
void InsertSort(SqList &L, int n) {
    int i, j;
    for (i = 2; i <= n; i++) {
        if (L[i - 1] > L[i]) {
            L[0] = L[i];
            for (j = i - 1; L[j] > L[0]; --j) {
                L[j + 1] = L[j];
            }
            L[j + 1] = L[0];
        }
    }
}
```



##	快速排序

- 右基准

```python
def sort(list, left, right):
    if left >= right:
        return

    mid = right
    tmp = list[mid]
    leftpoint = left
    rightpoint = right
    while leftpoint != rightpoint:
        while list[leftpoint] <= tmp and leftpoint < rightpoint:
            leftpoint += 1
        if leftpoint != rightpoint:
                list[rightpoint] = list[leftpoint]
                rightpoint -= 1
        while list[rightpoint] >= tmp and leftpoint < rightpoint:
            rightpoint -= 1
        if leftpoint != rightpoint:
                list[leftpoint] = list[rightpoint]
                leftpoint += 1
    list[leftpoint] = tmp
    print(list)
    sort(list, rightpoint + 1, right)
    sort(list, left, leftpoint - 1)
```

- 随机基数(双指针交换法)

   ```python
   import random
   
   
   def sort(list, left, right):
       if left >= right:
           return
   
       mid = random.randint(left, right)
       tmp = list[mid]
       leftpoint = left
       rightpoint = right
       while leftpoint < rightpoint:
           while list[leftpoint] < tmp and leftpoint < rightpoint:
               leftpoint += 1
           while list[rightpoint] > tmp and leftpoint < rightpoint:
               rightpoint -= 1
           list[leftpoint], list[rightpoint] = list[rightpoint], list[leftpoint]
           if list[leftpoint] == list[rightpoint] == tmp:
               leftpoint += 1
       sort(list, rightpoint + 1, right)
       sort(list, left, leftpoint - 1)
   ```
   

##	归并排序

![](E:\Study Notes\Pictures\merge_sort.png)

```python
def merge(list, start, mid, end):
    i = start
    j = mid + 1
    tmp = []
    while i <= mid and j <= end:  # 当两个子序列其中一个触碰到自身边界时退出
        if list[i] < list[j]:
            tmp.append(list[i])
            i += 1
        else:
            tmp.append(list[j])
            j += 1
    #   将剩余的有序部分依次添加到tmp数组中存储
    while i <= mid:
        tmp.append(list[i])
        i += 1
    while j <= end:
        tmp.append(list[j])
        j += 1
    list[start:end + 1] = tmp  # 将tmp列表覆盖原列表


def sort(list, start, end):
    if start < end:  # 当传入的子序列元素数为1时即退出递归
        mid = (start + end) // 2
        # 递归分割该序列，直至符合递归退出条件
        sort(list, start, mid)
        sort(list, mid + 1, end)
        merge(list, start, mid, end)  # 下层递归返回即说明返回的为相邻的两个有序子序列，对这两个子序列进行归并
    else:
        return
```



##	堆排序

> 堆排序使用堆的向下调整性质，分为创建堆和依次出数两个步骤，适用于完全二叉树
>
> 向下调整性质即堆顶元素向堆底方向寻找适合它的位置，使整个堆成为大根堆或小根堆

```python
def sift(list, start, end):  # 向下调整函数，start为堆顶，end为堆的最后一个元素的位置
    i = start
    j = 2 * i + 1
    tmp = list[start]
    while j <= end:
        if j + 1 <= end and list[j] < list[j + 1]:  # 比较根节点的两个子结点，最大的子结点和根结点之间进行比较
            j = j + 1
        if tmp < list[j]:   # 比较子结点与根结点大小，如果子结点比根节点大，则子结点上移一层
            list[i]= list[j]
            i = j
            j = 2 * i + 1
        else:
            list[i] = tmp   # 若子结点均比根结点小，则说明根结点已找到它的位置
            break
    else:
        list[i] = tmp   # 根结点位于叶子结点，则该位置为根结点所应处的位置


def heap(list):
    n = len(list) - 1   # 完全二叉树最下一层的最右端的叶子结点
    #   构建堆
    for i in range((n - 1) // 2, -1, -1):   # 从最小的堆开始构建，i为每个根结点的索引
        sift(list, i, n)
    #   依次出数
    for j in range(n, -1, -1):  # 将最后一个元素与首元素交换位置，堆底end往前进1，向下调整新的堆，重复此操作最终成为一个有序列表
        list[0], list[j] = list[j], list[0]
        sift(list, 0, j-1)
```

```c++
void sift(SqList&L, int start, int end) {
    int i = start, j = 2 * i;
    ElemType tmp = L[start];
    while (j <= end) {
        if (L[j] < L[j + 1] && (j + 1) <= end)
            j = j + 1;
        if (L[j] > tmp) {
            L[i] = L[j];
            i = j;
            j = 2 * i;
        } else {
            break;
        }
    }
    L[i] = tmp;
}

void HeapSort(SqList&L, int n) {
    int tmp;
    for (int i = n / 2; i >= 1; --i)
        sift(L, i, n);
    for (int j = n; j > 0; j--) {
        tmp = L[1];
        L[1] = L[j];
        L[j] = tmp;
        sift(L,1,j-1);
    }
}
```





##	希尔排序

> 希尔排序基于插入排序，希尔排序每次并不使某些元素有序，而是使整体数据越来越接近有序，最后一次排序使所有数据有序

```python
def insert_sort(list, gap):  # gap为步长
    for i in range(gap, len(list)):
        for j in range(i - gap, -1, -gap):
            if list[j] > list[j + gap]:
                t = list[j]
                list[j] = list[j + gap]
                list[j + gap] = t


def shell_sort(list):
    gap = len(list) // 2
    while gap >= 1:	
        insert_sort(list, gap)
        gap = gap // 2
```

```c++
void ShellInsert(SqList &L, int n, int dk) {
    int i, j;
    for (i = dk + 1; i <= n; ++i) {
        if (L[i] < L[i - dk]) {
            L[0] = L[i];
            for (j = i - dk; L[j] > L[0] && j > 0; j -= dk) {
                L[j + dk] = L[j];
            }
            L[j + dk] = L[0];
        }
    }
}

void ShellSort(SqList&L, int n) {
    int dk = n / 2;
    while (dk > 0) {
        ShellInsert(L, n, dk);
        dk = dk / 2;
    }
}
```



##	计数排序

> 需要已知待排序数据范围



##	桶排序

> 桶排序的表现取决于数据的分布，可改变桶排序的方法进行优化

```python
def bucket_sort(list, max_num=10000, n=100):  # max_num为数据最大范围，n为桶数
    tmp = [[] for _ in range(n)]  # 建立桶
    for i in list:
        j = min(i // (max_num // n), n - 1)  # 确定数据i应在编号为j的桶，max_num//n为单个桶存储的数据范围，超过最大数据范围的放入最后一个桶
        tmp[j].append(i)  # 将数据存入桶中
        for t in range(len(tmp[j]) - 1, 0, -1):  # 对桶中进行排序
            if tmp[j][t] < tmp[j][t - 1]:
                tmp[j][t], tmp[j][t - 1] = tmp[j][t - 1], tmp[j][t]
            else:
                break
    list.clear()
    for i in range(n):
        list.extend(tmp[i])  # 将tmp中的数据覆盖原列表
```





##	基数排序

> 运用多要素排序的思想，在数据范围不是极其大的情况下有非常快的排序速度，时间复杂度为kn

```python
def radix_sort(list):
    i = 0
    max_num = max(list)  # 通过最大元素确定需要获取基数的次数
    while 10 ** i <= max_num:
        tmp = [[] for _ in range(10)]
        for val in list:
            j = (val // (10 ** i)) % 10  # 根据val的基数放入对应的桶
            tmp[j].append(val)
        list.clear()
        for val in tmp:
            list.extend(val)  # 将桶中数据按照顺序覆盖原列表
        i += 1
```



#	顺序表

```c++
#include <stdio.h>
#include <stdlib.h>

#define ElemType int
#define Status int
#define OK 1
#define ERROR 0
#define InitSize 100

//顺序表


typedef struct SqList {
    ElemType *elem;
    int length;
    int listsize;
};

Status init(SqList &L) {
    ElemType *h;
    h = (ElemType *) malloc(InitSize * sizeof(ElemType));
    L.elem = h;
    L.length = 0;
    L.listsize = InitSize;
    return OK;
}

Status insert(SqList &L, int i, ElemType data) {
    ElemType *p;
    int j;
    if (L.length == L.listsize) {
        L.elem = (ElemType *) realloc(L.elem, sizeof(ElemType));
        L.listsize += 1;
    }
    p = L.elem;
    for (j = L.length; j > i; j--) {
        *(p + j) = *(p + j - 1);
    }
    *(p + j) = data;
    L.length += 1;
    return OK;
}

Status del(SqList &L, int i) {
    ElemType *p;
    p = L.elem;
    for (i -= 1; i < L.length - 1; i++) {
        *(p + i) = *(p + i + 1);
    }
    L.length -= 1;
    return OK;
}

Status display(SqList &L) {
    int i;
    ElemType *p;
    p = L.elem;
    for (i = 0; i < L.length; i++) {
        printf("%d ", *(p + i));
    }
    printf("\n");
    return OK;
}

int main() {
    struct SqList L;
    int i, j;
    ElemType data;

    Status init(SqList &L);
    Status insert(SqList &L, int i, ElemType data);
    Status del(SqList &L, int i);
    Status display(SqList &L);

    init(L);

    printf("输入要初始化的元素个数\n");
    scanf("%d", &i);
    for (j = 1; j <= i; j++) {
        scanf("%d", &data);
        insert(L, j, data);
    }
    display(L);

    printf("输入要插入的元素\n");
    scanf("%d", &data);
    printf("输入要插入的元素位置\n");
    scanf("%d", &i);
    insert(L, i, data);
    display(L);

    printf("输入要删除的元素位置\n");
    scanf("%d", &i);
    del(L, i);
    display(L);
    
    return 0;
}
```



#	哈希表(散列表)

1. 哈希表是一个通过哈希函数来计算数据存储位置的数据结构，哈希表由一个直接寻址表和一个哈希函数组成，哈希函数h(k)将元素关键字k作为自变量，返回元素的存储下标
2. 基础操作：
   1. insert(key,value)：插入键值对
   2. get(key)：如果存在键为key的键值对则返回其value，否则返回空值
   3. delete(key)：删除键为key的键值对
3. 哈希冲突：由于哈希表的大小是有限的，而要存储的值的总数量是无限的，因此对于任何哈希函数都会出现两个不同元素映射到同一个位置上的情况，这种情况叫做哈希冲突
4. 解决哈希冲突的方法：
   1. 开放寻址法：如果哈希函数返回的位置已经有值，则可以向后探查新的位置来存储这个值
      1. 线性探查：如果位置i被占用，则探查i+1，i+2，...
      2. 二次探查：如果位置i被占用，则探查i+1^2^，i-1^2^，i+2^2^，i-2^2^，...
      3. 二度哈希：有n个哈希函数，当使用第1个哈希函数h1发生冲突时，尝试使用h2，h3，...
   2. 拉链法：哈希表的每个位置都连接一个链表，当冲突发生时将冲突的元素加到该位置的链表后面
5. 常见哈希函数
   1. 除法哈希法
   2. 乘法哈希法
   3. 全域哈希法 
6. 哈希表的应用：md5算法、SHA2算法



#	栈

---

> 1. 栈是一个数据集合，可以理解为只能在一端进行插入或删除操作的数组
> 2. 栈的特点：后进先出 LIFO(lasst-in，first-out)
> 3. 基本操作：
>    1. 进栈(压栈)：push
>    2. 出栈：pop
>    3. 取栈顶：gettop
> 4. 应用：括号匹配问题
>
> 
>
> ![栈](E:\Study Notes\Pictures\栈)

##	基础功能

```python
class stack:
    def __init__(self):
        self.stack = []

    def push(self, element):  # 压栈
        self.stack.append(element)

    def pop(self):  # 出栈
        self.stack.pop()

    def gettop(self):  # 取栈顶
        if not self.is_empty():
            return self.stack[-1]
        else:
            return None

    def is_empty(self):
        lenth = len(self.stack)
        if lenth > 0:
            return 0
        else:
            return 1
```



##	括号匹配问题

```python
def brace_match(s):
    stack = basic.stack()
    match = {')': '(', ']': '[', '}': '{'}
    for ch in s:
        if ch in {'(', '[', '{'}:
            stack.push(ch)
        else:
            if stack.is_empty():
                return False
            elif match[ch] == stack.gettop():
                stack.pop()
            else:
                return False
    if stack.is_empty():
        return True
    else:
        return False
```



##	深度优先搜索

###	迷宫问题



```python
# 建立迷宫
maze = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]

# 设置下一步的方向
dirs = [
    lambda x, y: (x - 1, y),  # 向上进一步
    lambda x, y: (x + 1, y),  # 向下进一步
    lambda x, y: (x, y - 1),  # 向左进一步
    lambda x, y: (x, y + 1)   # 向右进一步
]


def maze_path(x1, y1, x2, y2):  # x1 y1为起点坐标，x2 y2为终点坐标
    stack = []  # 建立栈
    stack.append((x1, y1))  # 添加起点进栈
    while len(stack) > 0:  # 若栈不空，则对栈顶进行操作
        curNode = stack[-1]  # 当前坐标为栈顶
        if curNode[0] == x2 and curNode[1] == y2:  # 如果当前坐标为终点坐标则输出栈(路径)
            for i in stack:
                print(i)
            return True
        for dir in dirs:  # 对栈顶进行下一步的方向进行操作
            nextNode = dir(curNode[0], curNode[1])  # 下一步的方向
            if maze[nextNode[0]][nextNode[1]] == 0:  # 如果下一步在maze中为0，说明这一步可行
                stack.append(nextNode)  # 将可行的下一步坐标加入栈中
                maze[nextNode[0]][nextNode[1]] = 2  # 标记下一步已走过
                break  # 跳出当前循环，开始下一次的方向选择
        else:  # 如果所有方向都是1或2(已走过)
            maze[curNode[0]][curNode[1]] = 2  # 标记当前坐标为2(已走过)
            stack.pop()  # 栈顶出栈，回退一步
    else:  # 如果栈空，则说明无法到达终点
        return False


print(maze_path(1, 1, 8, 8))
```







#	队列

---

> 1. 队列是一个数据集合，仅允许在数组的一端进行插入，在另一端进行删除
> 2. 队列的特点：先进先出，FIFO(first-in，first out)
> 3. 进行插入的一端称为队尾(rear)，插入动作称为进队或入队
> 4. 进行删除的一端称为对头(front)，删除动作称为出队
> 5. 实现方式：环形队列，双向队列
>
> ![](E:\Study Notes\Pictures\队列)
>
> ![](E:\Study Notes\Pictures\环形队列)

##	基础功能

```python
class queue:
    def __init__(self, size):
        self.queue = [None for _ in range(size)]
        self.rear = 0
        self.front = 0
        self.size = size

    def push(self, element):
        if not self.is_filled():  # 队列满则无法入队
            self.rear = (self.rear + 1) % self.size
            self.queue[self.rear] = element
        else:
            return False

    def pop(self):
        if not self.is_empty():  # 队列空则无法出队
            self.front = (self.front + 1) % self.size
            return self.queue[self.front]
        else:
            return None

    def is_empty(self):
        if self.front == self.rear:
            return 1
        else:
            return 0

    def is_filled(self):
        if (self.rear + 1) % self.size == self.front:
            return 1
        else:
            return 0
```



##	广度优先搜索

### 迷宫问题

```python
import basic

# 建立迷宫
maze = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]

# 设置下一步的方向
dirs = [
    lambda x, y: (x - 1, y),  # 向上进一步
    lambda x, y: (x + 1, y),  # 向下进一步
    lambda x, y: (x, y - 1),  # 向左进一步
    lambda x, y: (x, y + 1)  # 向右进一步
]


def print_f(path):  # 打印路径
    realpath = []  # 实际路径
    curNode = path[-1]  # 从传入的路径最后一个元素(终点坐标)开始往前找实际路径
    while curNode[2] != -1:  # 如果坐标不是起点坐标，则继续往前查找
        realpath.append((curNode[0], curNode[1]))
        curNode = path[curNode[2]]
    realpath.append((curNode[0], curNode[1]))
    realpath.reverse()  # 将逆序的实际路径反转获得从起点到终点的实际路径
    for i in realpath:  # 打印输出
        print(i)


def maze_path(x1, y1, x2, y2):  # x1 y1为起点坐标，x2 y2为终点坐标
    queue = basic.queue(21)  # 实例化队列
    queue.push((x1, y1, -1))  # 设置起始坐标，将起点入队
    path = []  # 设置路径列表，元素为含有三个数据的元组，第一个元素为路径结点的x坐标，第二个元素为路径结点的y坐标，第三个元素为该路径结点的上一个结点在路径列表path中的索引
    while not queue.is_empty():  # 若队列不为空，则说明仍然可以寻找路径
        curNode = queue.pop()  # 队首出队，作为查找路径的结点
        path.append(curNode)  # 将出队的队首放入路径列表path中
        for dir in dirs:  # 查找curNode的四个方向是否可以前进一步
            nextNode = dir(curNode[0], curNode[1])  # 可前进的下一步的坐标
            if nextNode == (x2, y2):  # 查找到终点，说明有路径可以到达，打印输出
                path.append((x2, y2, len(path) - 1))
                print_f(path)
                return True
            if maze[nextNode[0]][nextNode[1]] == 0:  # 如果下一个结点的坐标可前进
                queue.push((nextNode[0], nextNode[1],
                            len(path) - 1))  # 将该坐标加入队列中作为之后查找的起始结点，len(path)-1为上一个结点在路径列表path中的索引(即列表终点最后一个元素)
                maze[nextNode[0]][nextNode[1]] = 2  # 将该已查找过的坐标进行标记
    else:  # 若队列为空，说明没有路径到达终点
        return False


print(maze_path(1, 1, 8, 8))
```





#	链表

---

> 1. 链表是由一系列节点组成的元素集合
> 2. 每个节点包含两部分：数据域item和指向下一个节点的指针next

##	基础功能

```python
class Node:
    def __init__(self, item):
        self.item = item
        self.next = None


def create_head_insert(list):  # 头插法创建列表
    head = Node(list[0])
    for item in list[1:]:
        node = Node(item)
        node.next = head
        head = node
    return head


def create_tail_insert(list):  # 尾插法创建列表
    head = Node(list[0])
    tail = head
    for item in list[1:]:
        node = Node(item)
        tail.next = node
        tail = node
    return head


def traverse(head):  # 遍历
    point = head
    while point:
        print(point.item, end=' ')
        point = point.next
    print('\n')


def insert(head, num, item):  # 在num节点后插入数据item
    curNode = head
    for _ in range(num - 1):
        curNode = curNode.next
    nextNode = Node(item)
    nextNode.next = curNode.next
    curNode.next = nextNode


def delete(head, num):  # 删除num节点
    curNode = head
    for _ in range(num - 2):
        curNode = curNode.next
    nextNode = curNode.next
    curNode.next = nextNode.next


linklist = create_tail_insert([i for i in range(11)])
traverse(linklist)
insert(linklist, 5, 100)
traverse(linklist)
delete(linklist, 6)
traverse(linklist)
```



```c++
#include <stdio.h>
#include <stdlib.h>

#define Status int
#define ElemType int
#define OK 1
#define ERROR 0

//单链表

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} *LinkList;

Status init(LinkList &L, int i, ElemType *elem) {
    int j;
    LNode *p, *q;

    L = (LNode *) malloc(sizeof(LNode));
    L->next = NULL;
    p = L;
    for (j = 0; j < i; j++) {
        q = (LNode *) malloc(sizeof(LNode));
        q->data = elem[j];
        q->next = NULL;
        p->next = q;
        p = p->next;
    }
    return OK;
}

Status display(LinkList &L) {
    LNode *p;
    p = L->next;
    while (p) {
        printf("%d ", p->data);
        p = p->next;
    }
    return OK;
}

Status insert(LinkList &L, int i, ElemType data) {
    LNode *p, *q;
    p = L->next;
    for (int j = 1; j < i - 1; ++j) {
        p = p->next;
    }
    q = (LNode *) malloc(sizeof(LNode));
    q->data = data;
    q->next = p->next;
    p->next = q;
    return 0;
}

Status del(LinkList &L, int i) {
    LNode *p, *q;
    p = L->next;
    for (int j = 1; j < i - 1; ++j) {
        p = p->next;
    }
    q = p->next;
    p->next = p->next->next;
    free(q);

    return 0;
}

int main() {
    ElemType *elem, data;
    int n, j;
    LinkList L;

    scanf("%d", &n);
    elem = (ElemType *) malloc(sizeof(ElemType) * n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &elem[i]);
    }
    init(L, n, elem);
    display(L);

    printf("\n输入要插入的元素\n");
    scanf("%d", &data);
    printf("输入要插入的元素位置\n");
    scanf("%d", &j);
    insert(L, j, data);
    display(L);

    printf("\n输入要删除的元素位置\n");
    scanf("%d", &j);
    del(L, j);
    display(L);

    return 0;
}
```



##	双链表

```python
class Node:
    def __init__(self, item):
        self.item = item
        self.prior = None
        self.next = None
```



#	树

---

> 数据结构中的元素存在一对多的相互关系
>
> 1. 树是一种可以递归定义的数据结构
> 2. 树是由n个结点组成的集合
>    1. 如果n=0，那这是一棵空树
>    2. 如果n>0，那存在1个结点作为树的根结点，其他结点可以分为m个集合，每个集合本身又是一棵树

##	基础二叉树

> 存储方式：
>
> 1. 顺序存储：使用数组/列表，第i个结点的子结点为2i+1/2i+2
> 2. 链式存储：将二叉树的结点定义为一个对象，结点之间通过类似链表的链接方式来连接

```python
class BiTreeNode:
    def __init__(self, data):
        self.data = data
        self.lchild = None
        self.rchild = None
```



###	构建二叉树

```c
Status CreateBiTree(BiTree &T) {
    char ch;
    scanf("%c", &ch);
    if (ch == '#') T = NULL;
    else {
        T = (BiTNode *) malloc(sizeof(BiTNode));
        T->data = ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
    return OK;
}
```



###	遍历

>  通过前序遍历和中序遍历可以确定二叉树的结构
>
> 层次遍历使用队列实现

```python
def pre_order(root):  # 前序遍历
    if root != None:
        print(root.data, end=',')
        pre_order(root.lchild)
        pre_order(root.rchild)


def in_order(root):  # 中序遍历
    if root != None:
        in_order(root.lchild)
        print(root.data, end=',')
        in_order(root.rchild)


def post_order(root):  # 后序遍历
    if root != None:
        post_order(root.lchild)
        post_order(root.rchild)
        print(root.data)


import Queue.basic


def level_order(root, size):  # 层次遍历
    queue = Queue.basic.queue(size)
    queue.push(root)
    while not queue.is_empty():
        node = queue.pop()
        print(node.data, end=',')
        if node.lchild != None:
            queue.push(node.lchild)
        if node.rchild != None:
            queue.push(node.rchild)
```

```c++
//非递归算法
void PreOrderTraverse(BiTree T, Status (*Visit)(TElemType e)) {
    InitStack(S);
    Push(S, T);
    while (!StackEmpty(S)) {
        while (GetTop(S, p) && p) { //走到左子树的尽头，p限制左孩子，GetTop(S, p)限制右孩子
            Visit(p->data);
            Push(S, p->lchild);
        }
        Pop(S, p);  //空指针出栈
        if (!StackEmpty(S)) {   //右孩子进栈
            Pop(S, p);
            Push(S, p->rchild);
        }
    }
}
```



###	交换左右子树

```c++
#include "stdio.h"
#include "stdlib.h"

#define Status int
#define OK 1
#define ERROR 0
#define INITSIZE 100
#define ElemType char

typedef struct BiTNode {
    ElemType data;
    BiTNode *lchild;
    BiTNode *rchild;
} BiTNode, *BiTree;

Status CreateBiTree(BiTree &T) {
    char ch;
    scanf("%c", &ch);
    if (ch == '#') T = NULL;
    else {
        T = (BiTNode *) malloc(sizeof(BiTNode));
        T->data = ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
    return OK;
}

Status Exchange(BiTree &T) {
    BiTNode *tmp;
    if (T->lchild != NULL && T->rchild != NULL) {
        Exchange(T->lchild);
        Exchange(T->rchild);
    }
    tmp = T->lchild;
    T->lchild = T->rchild;
    T->rchild = tmp;
    return OK;
}

Status PreOrderTraverse(BiTree T) {
    if (T) {
        printf("%c", T->data);
        PreOrderTraverse(T->lchild);
        PreOrderTraverse(T->rchild);
    }
    return OK;
}

Status main() {
    BiTree T;
    CreateBiTree(T);
    Exchange(T);
    PreOrderTraverse(T);
    return OK;
}
```



##	哈夫曼树

```C
#include "stdio.h"
#include "stdlib.h"
#include "string"

#define Status int
#define OK 1
#define ERROR 0
#define LENGTH 200
#define ElemType char

typedef struct HTNode {
    int weight;
    int parent, lchild, rchild;
} HTNode, *HuffmanTree; //动态分配数组存储哈夫曼树

typedef char **HuffmanCode; //动态分配哈夫曼编码表

Status Select(HuffmanTree HT, int n, int &s1, int &s2) {
    int min;
    int i;
    for (i = 1; i <= n; ++i)
        if (HT[i].parent == 0) {
            min = HT[i].weight;
            s1 = s2 = i;
            break;
        }

    for (int j = i; j <= n; ++j)
        if (HT[j].parent == 0 && HT[j].weight < min) {
            min = HT[j].weight;
            s1 = j;
        }

    min = HT[i].weight;
    for (int j = i; j <= n; ++j) {
        if (j == s1) {
            if (s1 == i) {
                for (int t = i + 1; t <= n; ++t)
                    if (HT[t].parent == 0) {
                        min = HT[t].weight;
                        s2 = t;
                        break;
                    }
            }
            continue;
        }
        if (HT[j].parent == 0 && HT[j].weight < min) {
            min = HT[j].weight;
            s2 = j;
        }
    }
    return OK;
}

Status HuffmanEncode(HuffmanTree &HT, HuffmanCode &HC, int *w, int n) {   //w存放n个字符的权值
    int m, s1, s2, start;
    char *cd;
    m = 2 * n - 1;  //哈夫曼树结点个数
    HT = (HTNode *) malloc((m + 1) * sizeof(HTNode));  //动态分配数组存储哈夫曼树
    //数组初始化
    for (int i = 1; i <= n; ++i)
        HT[i] = {*(w + i - 1), 0, 0, 0};
    for (int i = n + 1; i <= m; ++i)
        HT[i] = {0, 0, 0, 0};

    for (int i = n + 1; i <= m; ++i) {  //创建哈夫曼树
        Select(HT, i - 1, s1, s2);
        HT[i].weight = HT[s1].weight + HT[s2].weight;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[s1].parent = i;
        HT[s2].parent = i;
    }
    HC = (char **) malloc((n + 1) * sizeof(char *));    //分配n个字符编码的头指针向量，即指向以字符数组为元素的数组的指针
    cd = (char *) malloc(n * sizeof(char));  //分配求编码的工作空间，即指向一个字符数组的指针
    cd[n - 1] = '\0'; //编码结束符位置
    for (int i = 1; i <= n; ++i) {
        start = n - 2;
        for (int c = i, f = HT[i].parent; f != 0; c = f, f = HT[f].parent) {
            if (HT[f].lchild == c) cd[start--] = '0';
            else cd[start--] = '1';
        }
        HC[i] = (char *) malloc((n - start) * sizeof(char));
        strcpy(HC[i], &cd[start + 1]);
    }
    free(cd);
    return OK;
}

Status HuffmanDecode(HuffmanTree HT, char *str, int n, char *ch) {
    int p1, p2, m;
    m = 2 * n - 1;
    p1 = 0;
    p2 = m;
    while (str[p1] != '\0') {
        if (str[p1] == '0')
            p2 = HT[p2].lchild;
        else
            p2 = HT[p2].rchild;
        if (p2 <= n) {
            printf("%c", ch[p2 - 1]);
            p2 = m;
        }
        p1++;
    }
    return OK;
}


Status main() {
    Status HuffmanEncode(HuffmanTree &HT, HuffmanCode &HC, int *w, int n);
    Status HuffmanDecode(HuffmanTree HT, char *str, int n, char *ch);

    char ch[LENGTH], str[LENGTH];
    HuffmanTree HT;
    HuffmanCode HC;
    int n, *w;

    scanf("%d", &n);
    w = (int *) malloc(n * sizeof(int));
    for (int i = 0; i < n; ++i)
        scanf("%d", &w[i]);
    scanf("%s", ch);
    scanf("%s", str);
    HuffmanEncode(HT, HC, w, n);
    HuffmanDecode(HT, str, n, ch);

    return OK;
}
```



## 最小生成树

### Prime算法

```c++
#include<iostream>
#include<cstdlib>
#include<fstream>

using namespace std;

#define MAXNUM 100
#define MAXINT 32767
#define OK 1
#define ERROR 0

#define vexs 6        //图的顶点数
#define arcs 10       //图的边数

typedef struct
{
    int vex[MAXNUM];
    int arc[MAXNUM][MAXNUM];
    int vexnum, arcnum;
} AMGraph;

typedef struct
{
    int adjvex;
    int lowcost;
} closedge;

void creatUDN(AMGraph &G)
{
    int i,j,k,v1,v2,w;
    G.vexnum=vexs;
    G.arcnum=arcs;

    //顶点信息，以整数表示，方便查找顶点下标，下标等于顶点值减1，输出的时候可加字母前缀
    for(i=0; i<G.vexnum; i++)
    {
        G.vex[i]=i+1;
    }

    for(i=0; i<G.vexnum; i++)
        for(j=0; j<G.vexnum; j++)
            G.arc[i][j]=MAXINT;

    //边的权值，从文件读取数据，代替手动输入
    ifstream infile("input.txt",ios::in);
    for(k=0; k<G.arcnum; k++)
    {
        infile>>v1>>v2>>w;
        i=v1-1;
        j=v2-1;
        G.arc[i][j]=w;
        G.arc[j][i]=G.arc[i][j];
    }
    infile.close();
}

//返回closedge数组中不为0的最小值的下标，为0表示该点已经并入U集
int min_closedge(closedge close_arr[],int u)
{
    int i,min,min_k;
    min=MAXINT;
    min_k=0;
    for(i=1; i<u ; i++)
    {
        if((close_arr[i].lowcost<min) && (close_arr[i].lowcost!=0))
        {
            min=close_arr[i].lowcost;
            min_k=i;
        }
    }
    return min_k;
}

//MST算法
void MST(AMGraph G, int u)
{
    int i,j,k,u0,v0;
    k=u-1;   //下标直接用顶点值减1获得
    closedge close_arr[vexs];
    for(j=0; j<G.vexnum; j++)
    {
        if(j!=k)
        {
            close_arr[j].adjvex=u;
            close_arr[j].lowcost=G.arc[k][j];
        }
    }
    close_arr[k].lowcost=0;

    for(i=1; i<G.vexnum; i++)
    {
        k=min_closedge(close_arr,vexs);
        u0=close_arr[k].adjvex;
        v0=G.vex[k];
        cout<<"v"<<u0<<"  "<<"v"<<v0;
        close_arr[k].lowcost=0;
        for(j=0; j<G.vexnum; j++)
        {
            if(G.arc[k][j]<close_arr[j].lowcost)
            {
                close_arr[j].adjvex=G.vex[k];
                close_arr[j].lowcost=G.arc[k][j];
            }
        }
        cout<<endl;
    }
}

int main()
{
    AMGraph G;
    creatUDN(G);
    MST(G,1);
    return 0;
}
```





### kruskal算法



## 线段树

### 不带标记的线段树

```c++
template<typename type>
class Segment_Tree {
public:
    Segment_Tree(int n, type *array) {
        max_n = 4 * n + 1;
        tree = new type[max_n];
        this->array = array;
        build_tree(1, 1, n);
    }

    ~Segment_Tree() {
        array = nullptr;
        delete[] tree;
    }

    void add(int k, int l, int r, int key, type value); //对第key个数进行操作
    type calculate(int k, int l, int r, int range_left, int range_right);   //求range_left到range_right范围内的数的和
    void display();

private:
    type *tree, *array;
    int number = 0, max_n;

    void build_tree(int k, int l, int r);
};

template<typename type>
void Segment_Tree<type>::display() {
    int t = 1, m = 1;
    bool flag = false;
    while (m <= number) {
        for (int i = 0; i < t; ++i) {
            if (m > number) {
                flag = true;
                break;
            }
            cout << tree[m] << " ";
            m++;
        }
        cout << endl;
        if (flag) break;
        t *= 2;
    }
}

template<typename type>
type Segment_Tree<type>::calculate(int k, int l, int r, int range_left,
                                   int range_right) {  //l、r是当前节点存储的数据范围，range_left、range_right是需要的数据范围
    if (l == range_left && r == range_right)
        return tree[k];
    int mid = (range_left + range_right) / 2;
    if (range_right <= mid)
        calculate(2 * k, l, mid, range_left, range_right);
    else if (range_left >= mid + 1)
        calculate(2 * k + 1, mid + 1, r, range_left, range_right);
    else
        return calculate(2 * k, l, mid, range_left, mid) + calculate(2 * k + 1, mid + 1, r, mid + 1, range_right);
}

template<typename type>
void Segment_Tree<type>::add(int k, int l, int r, int key, type value) {
    tree[k] += value;
    if (l == r) return;
    int mid = (l + r) / 2;
    if (key <= mid)
        add(2 * k, l, mid, key, value);
    else
        add(2 * k + 1, mid + 1, r, key, value);
}

template<typename type>
void Segment_Tree<type>::build_tree(int k, int l, int r) {
    if (l == r) {
        tree[k] = array[l];
        number++;
        return;
    }
    int mid = (l + r) / 2;
    build_tree(2 * k, l, mid);
    build_tree(2 * k + 1, mid + 1, r);
    tree[k] = tree[2 * k] + tree[2 * k + 1];
    number++;
}
```



### 带标记的线段树

```c++
template<typename type>
class Segment_Tree {
public:
    Segment_Tree(int n, type *array) {
        max_n = 4 * n + 1;
        tree = new type[max_n];
        lazy = new type[max_n];
        this->array = array;
        build_tree(1, 1, n);
    }

    ~Segment_Tree() {
        array = nullptr;
        delete[] tree;
        delete[] lazy;
    }

    void insert(int k, int l, int r, int x, int y, type z);  //k是当前节点，对l~r范围内的x~y都加上z
    type search(int k, int l, int r, int x, int y, type p); //求x~y内的数的和,p是当前树路径下lazy的和
    void display();

private:
    type *tree, *array, *lazy;  //lazy标记数组仅影响以目标节点为根节点的子树
    int number = 0, max_n;

    void build_tree(int k, int l, int r);
};

template<typename type>
type Segment_Tree<type>::search(int k, int l, int r, int x, int y, type p) {
    p += lazy[k];   //累积目标节点的祖先节点中的影响
    if (l == x && r == y)
        return p * (r - l + 1) + tree[k];

    int mid = (l + r) / 2;
    if (y <= mid)
        return search(2 * k, l, mid, x, y, p);
    else if (x >= mid + 1)
        return search(2 * k + 1, mid + 1, r, x, y, p);
    else
        return search(2 * k, l, mid, x, mid, p) + search(2 * k + 1, mid + 1, r, mid + 1, y, p);
}

template<typename type>
void Segment_Tree<type>::insert(int k, int l, int r, int x, int y, type z) {
    if (l == x && r == y) {
        lazy[k] += z;
        return;
    }

    tree[k] += (y - x + 1) * z; //对于目标节点的祖先节点排除lazy标记的影响，在tree中直接记录结果

    int mid = (l + r) / 2;
    if (y <= mid)
        insert(2 * k, l, mid, x, y, z);
    else if (x >= mid + 1)
        insert(2 * k + 1, mid + 1, r, x, y, z);
    else {
        insert(2 * k, l, mid, x, mid, z);
        insert(2 * k + 1, mid + 1, r, mid + 1, y, z);
    }
}

template<typename type>
void Segment_Tree<type>::display() {
    int t = 1, m = 1;
    bool flag = false;
    while (m <= number) {
        for (int i = 0; i < t; ++i) {
            if (m > number) {
                flag = true;
                break;
            }
            cout << tree[m] << " ";
            m++;
        }
        cout << endl;
        if (flag) break;
        t *= 2;
    }
}


template<typename type>
void Segment_Tree<type>::build_tree(int k, int l, int r) {
    if (l == r) {
        tree[k] = array[l];
        number++;
        return;
    }
    int mid = (l + r) / 2;
    build_tree(2 * k, l, mid);
    build_tree(2 * k + 1, mid + 1, r);
    tree[k] = tree[2 * k] + tree[2 * k + 1];
    number++;
}
```



### 标记下传

```c++
template<typename type>
class Segment_Tree {
public:
    Segment_Tree(int n, type *array) {
        max_n = 4 * n + 1;
        tree = new type[max_n];
        lazy = new type[max_n];
        this->array = array;
        build_tree(1, 1, n);
    }

    ~Segment_Tree() {
        array = nullptr;
        delete[] tree;
        delete[] lazy;
    }

    void add(int k, int l, int r, int key, type value); //对第key个数进行操作
    type calculate(int k, int l, int r, int range_left, int range_right);   //求range_left到range_right范围内的数的和
    void insert(int k, int l, int r, int x, int y, type z);  //k是当前节点，对l~r范围内的x~y都加上z
    type search(int k, int l, int r, int x, int y); //求x~y内的数的和
    void display();

private:
    type *tree, *array, *lazy;  //lazy标记数组仅影响以目标节点为根节点的子树
    int number = 0, max_n;

    void build_tree(int k, int l, int r);

    void down(int &k);

    void up(int &k, int &mid, int &l, int &r);
};

template<typename type>
void Segment_Tree<type>::up(int &k, int &mid, int &l, int &r) {
    tree[k] = tree[2 * k] + lazy[2 * k] * (mid - l + 1) + tree[2 * k + 1] + lazy[2 * k + 1] * (r - mid);
}

template<typename type>
void Segment_Tree<type>::down(int &k) {
    if (lazy[k]) {  //标记下传
        lazy[2 * k] += lazy[k];
        lazy[2 * k + 1] += lazy[k];
        lazy[k] = 0;
    }
}

template<typename type>
type Segment_Tree<type>::search(int k, int l, int r, int x, int y) {
    if (l == x && r == y)
        return tree[k] + lazy[k] * (r - l + 1);

    down(k);
    int mid = (l + r) / 2;
    type res;
    if (y <= mid)
        res = search(2 * k, l, mid, x, y);
    else if (x >= mid + 1)
        res = search(2 * k + 1, mid + 1, r, x, y);
    else
        res = search(2 * k, l, mid, x, mid) + search(2 * k + 1, mid + 1, r, mid + 1, y);
    up(k, mid, l, r);
    return res;
}

template<typename type>
void Segment_Tree<type>::insert(int k, int l, int r, int x, int y, type z) {
    if (l == x && r == y) {
        lazy[k] += z;
        return;
    }
    down(k);

    int mid = (l + r) / 2;
    if (y <= mid)
        insert(2 * k, l, mid, x, y, z);
    else if (x >= mid + 1)
        insert(2 * k + 1, mid + 1, r, x, y, z);
    else {
        insert(2 * k, l, mid, x, mid, z);
        insert(2 * k + 1, mid + 1, r, mid + 1, y, z);
    }

    up(k, mid, l, r);
}

template<typename type>
void Segment_Tree<type>::display() {
    int t = 1, m = 1;
    bool flag = false;
    while (m <= number) {
        for (int i = 0; i < t; ++i) {
            if (m > number) {
                flag = true;
                break;
            }
            cout << tree[m] << " ";
            m++;
        }
        cout << endl;
        if (flag) break;
        t *= 2;
    }
}

template<typename type>
type Segment_Tree<type>::calculate(int k, int l, int r, int range_left,
                                   int range_right) {  //l、r是当前节点存储的数据范围，range_left、range_right是需要的数据范围
    if (l == range_left && r == range_right)
        return tree[k];
    int mid = (range_left + range_right) / 2;
    if (range_right <= mid)
        calculate(2 * k, l, mid, range_left, range_right);
    else if (range_left >= mid + 1)
        calculate(2 * k + 1, mid + 1, r, range_left, range_right);
    else
        return calculate(2 * k, l, mid, range_left, mid) + calculate(2 * k + 1, mid + 1, r, mid + 1, range_right);
}

template<typename type>
void Segment_Tree<type>::add(int k, int l, int r, int key, type value) {
    tree[k] += value;
    if (l == r) return;
    int mid = (l + r) / 2;
    if (key <= mid)
        add(2 * k, l, mid, key, value);
    else
        add(2 * k + 1, mid + 1, r, key, value);
}

template<typename type>
void Segment_Tree<type>::build_tree(int k, int l, int r) {
    lazy[k] = 0;
    if (l == r) {
        tree[k] = array[l];
        number++;
        return;
    }
    int mid = (l + r) / 2;
    build_tree(2 * k, l, mid);
    build_tree(2 * k + 1, mid + 1, r);
    tree[k] = tree[2 * k] + tree[2 * k + 1];
    number++;
}
```



## 替罪羊树

```java
package net.mooctest;

/**
 * Some syntactic sugar for math operations.
 * 
 * @author Ignas Lelys
 * @created May 3, 2011
 *
 */
public class MathUtils {
    
    /**
     * Extracts digit from integer number.
     * 
     * @param number Number from which digit is extracted.
     * @param digitIndex index of digit to get. 0 - last one.
     * 
     * @return Required digit.
     */
    public static int getDigitFromNumber(int number, int digitIndex) {
        // TODO error check and efficiency (maybe put powers of 10 to array)
        return number / (int)Math.pow(10, digitIndex) % 10;
    }
    
    /**
     * Returns bigger integer.
     * 
     * @param first First number.
     * @param second Second number.
     * @return Bigger number.
     */
    public static int getMax(int first, int second) {
        return first > second ? first : second;
    }
    
    /**
     * Calculates logarithm.
     */
    public static double logarithm(double base, double a) {
        return Math.log(a) / Math.log(base);
    }

}
```

```java
package net.mooctest;

/**
 * Abstract binary search tree implementation. Its basically fully implemented
 * binary search tree, just template method is provided for creating Node (other
 * trees can have slightly different nodes with more info). This way some code
 * from standart binary search tree can be reused for other kinds of binary
 * trees.
 * 
 * @author Ignas Lelys
 * @created Jun 29, 2011
 * 
 */
public abstract class AbstractBinarySearchTree {

    /** Root node where whole tree starts. */
    public Node root;

    /** Tree size. */
    protected int size;

    /**
     * Because this is abstract class and various trees have different additional information on 
     * different nodes subclasses uses this abstract method to create nodes (maybe of class {@link Node}
     * or maybe some different node sub class).
     * 
     * @param value Value that node will have.
     * @param parent Node's parent.
     * @param left Node's left child.
     * @param right Node's right child.
     * @return Created node instance.
     */
    protected abstract Node createNode(int value, Node parent, Node left, Node right);

    /**
     * Finds a node with concrete value. If it is not found then null is
     * returned.
     * 
     * @param element
     *            Element value.
     * @return Node with value provided, or null if not found.
     */
    public Node search(int element) {
        Node node = root;
        while (node != null && node.value != null && node.value != element) {
            if (element < node.value) {
                node = node.left;
            } else {
                node = node.right;
            }
        }
        return node;
    }

    /**
     * Insert new element to tree.
     * 
     * @param element
     *            Element to insert.
     */
    public Node insert(int element) {
        if (root == null) {
            root = createNode(element, null, null, null);
            size++;
            return root;
        }

        Node insertParentNode = null;
        Node searchTempNode = root;
        while (searchTempNode != null && searchTempNode.value != null) {
            insertParentNode = searchTempNode;
            if (element < searchTempNode.value) {
                searchTempNode = searchTempNode.left;
            } else {
                searchTempNode = searchTempNode.right;
            }
        }

        Node newNode = createNode(element, insertParentNode, null, null);
        if (insertParentNode.value > newNode.value) {
            insertParentNode.left = newNode;
        } else {
            insertParentNode.right = newNode;
        }

        size++;
        return newNode;
    }

    /**
     * Removes element if node with such value exists.
     * 
     * @param element
     *            Element value to remove.
     * 
     * @return New node that is in place of deleted node. Or null if element for
     *         delete was not found.
     */
    public Node delete(int element) {
        Node deleteNode = search(element);
        if (deleteNode != null) {
            return delete(deleteNode);
        } else {
            return null;
        }
    }

    /**
     * Delete logic when node is already found.
     * 
     * @param deleteNode
     *            Node that needs to be deleted.
     * 
     * @return New node that is in place of deleted node. Or null if element for
     *         delete was not found.
     */
    protected Node delete(Node deleteNode) {
        if (deleteNode != null) {
            Node nodeToReturn = null;
            if (deleteNode != null) {
                if (deleteNode.left == null) {
                    nodeToReturn = transplant(deleteNode, deleteNode.right);
                } else if (deleteNode.right == null) {
                    nodeToReturn = transplant(deleteNode, deleteNode.left);
                } else {
                    Node successorNode = getMinimum(deleteNode.right);
                    if (successorNode.parent != deleteNode) {
                        transplant(successorNode, successorNode.right);
                        successorNode.right = deleteNode.right;
                        successorNode.right.parent = successorNode;
                    }
                    transplant(deleteNode, successorNode);
                    successorNode.left = deleteNode.left;
                    successorNode.left.parent = successorNode;
                    nodeToReturn = successorNode;
                }
                size--;
            }
    
            return nodeToReturn;
        }
        return null;
    }

    /**
     * Put one node from tree (newNode) to the place of another (nodeToReplace).
     * 
     * @param nodeToReplace
     *            Node which is replaced by newNode and removed from tree.
     * @param newNode
     *            New node.
     * 
     * @return New replaced node.
     */
    private Node transplant(Node nodeToReplace, Node newNode) {
        if (nodeToReplace.parent == null) {
            this.root = newNode;
        } else if (nodeToReplace == nodeToReplace.parent.left) {
            nodeToReplace.parent.left = newNode;
        } else {
            nodeToReplace.parent.right = newNode;
        }
        if (newNode != null) {
            newNode.parent = nodeToReplace.parent;
        }
        return newNode;
    }

    /**
     * @param element
     * @return true if tree contains element.
     */
    public boolean contains(int element) {
        return search(element) != null;
    }

    /**
     * @return Minimum element in tree.
     */
    public int getMinimum() {
        return getMinimum(root).value;
    }

    /**
     * @return Maximum element in tree.
     */
    public int getMaximum() {
        return getMaximum(root).value;
    }

    /**
     * Get next element element who is bigger than provided element.
     * 
     * @param element
     *            Element for whom descendand element is searched
     * @return Successor value.
     */
    // TODO Predecessor
    public int getSuccessor(int element) {
        return getSuccessor(search(element)).value;
    }

    /**
     * @return Number of elements in the tree.
     */
    public int getSize() {
        return size;
    }

    /**
     * Tree traversal with printing element values. In order method.
     */
    public void printTreeInOrder() {
        printTreeInOrder(root);
    }

    /**
     * Tree traversal with printing element values. Pre order method.
     */
    public void printTreePreOrder() {
        printTreePreOrder(root);
    }

    /**
     * Tree traversal with printing element values. Post order method.
     */
    public void printTreePostOrder() {
        printTreePostOrder(root);
    }

    /*-------------------PRIVATE HELPER METHODS-------------------*/

    private void printTreeInOrder(Node entry) {
        if (entry != null) {
            printTreeInOrder(entry.left);
            if (entry.value != null) {
                System.out.println(entry.value);
            }
            printTreeInOrder(entry.right);
        }
    }

    private void printTreePreOrder(Node entry) {
        if (entry != null) {
            if (entry.value != null) {
                System.out.println(entry.value);
            }
            printTreeInOrder(entry.left);
            printTreeInOrder(entry.right);
        }
    }

    private void printTreePostOrder(Node entry) {
        if (entry != null) {
            printTreeInOrder(entry.left);
            printTreeInOrder(entry.right);
            if (entry.value != null) {
                System.out.println(entry.value);
            }
        }
    }

    protected Node getMinimum(Node node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }

    protected Node getMaximum(Node node) {
        while (node.right != null) {
            node = node.right;
        }
        return node;
    }

    protected Node getSuccessor(Node node) {
        // if there is right branch, then successor is leftmost node of that
        // subtree
        if (node.right != null) {
            return getMinimum(node.right);
        } else { // otherwise it is a lowest ancestor whose left child is also
            // ancestor of node
            Node currentNode = node;
            Node parentNode = node.parent;
            while (parentNode != null && currentNode == parentNode.right) {
                // go up until we find parent that currentNode is not in right
                // subtree.
                currentNode = parentNode;
                parentNode = parentNode.parent;
            }
            return parentNode;
        }
    }
    
    //-------------------------------- TREE PRINTING ------------------------------------

    public void printTree() {
        printSubtree(root);
    }
    
    public void printSubtree(Node node) {
        if (node.right != null) {
            printTree(node.right, true, "");
        }
        printNodeValue(node);
        if (node.left != null) {
            printTree(node.left, false, "");
        }
    }
    
    private void printNodeValue(Node node) {
        if (node.value == null) {
            System.out.print("<null>");
        } else {
            System.out.print(node.value.toString());
        }
        System.out.println();
    }
    
    private void printTree(Node node, boolean isRight, String indent) {
        if (node.right != null) {
            printTree(node.right, true, indent + (isRight ? "        " : " |      "));
        }
        System.out.print(indent);
        if (isRight) {
            System.out.print(" /");
        } else {
            System.out.print(" \\");
        }
        System.out.print("----- ");
        printNodeValue(node);
        if (node.left != null) {
            printTree(node.left, false, indent + (isRight ? " |      " : "        "));
        }
    }


    public static class Node {
        public Node(Integer value, Node parent, Node left, Node right) {
            super();
            this.value = value;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

        public Integer value;
        public Node parent;
        public Node left;
        public Node right;
        
        public boolean isLeaf() {
            return left == null && right == null;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((value == null) ? 0 : value.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            Node other = (Node) obj;
            if (value == null) {
                if (other.value != null)
                    return false;
            } else if (!value.equals(other.value))
                return false;
            return true;
        }

    }
}
```

```java
package net.mooctest;

/**
 * Abstract class for self balancing binary search trees. Contains some methods
 * that is used for self balancing trees.
 * 
 * @author Ignas Lelys
 * @created Jul 24, 2011
 * 
 */
public abstract class AbstractSelfBalancingBinarySearchTree extends AbstractBinarySearchTree {

    /**
     * Rotate to the left.
     * 
     * @param node Node on which to rotate.
     * @return Node that is in place of provided node after rotation.
     */
    protected Node rotateLeft(Node node) {
        Node temp = node.right;
        temp.parent = node.parent;

        node.right = temp.left;
        if (node.right != null) {
            node.right.parent = node;
        }

        temp.left = node;
        node.parent = temp;

        // temp took over node's place so now its parent should point to temp
        if (temp.parent != null) {
            if (node == temp.parent.left) {
                temp.parent.left = temp;
            } else {
                temp.parent.right = temp;
            }
        } else {
            root = temp;
        }
        
        return temp;
    }

    /**
     * Rotate to the right.
     * 
     * @param node Node on which to rotate.
     * @return Node that is in place of provided node after rotation.
     */
    protected Node rotateRight(Node node) {
        Node temp = node.left;
        temp.parent = node.parent;

        node.left = temp.right;
        if (node.left != null) {
            node.left.parent = node;
        }

        temp.right = node;
        node.parent = temp;

        // temp took over node's place so now its parent should point to temp
        if (temp.parent != null) {
            if (node == temp.parent.left) {
                temp.parent.left = temp;
            } else {
                temp.parent.right = temp;
            }
        } else {
            root = temp;
        }
        
        return temp;
    }

}
```

```java
package net.mooctest;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;



/**
 * Scapegoat tree non recursive implementation.
 * Warning: not sure if my implementations is really correct, didn't have time to learn more about scapegoat trees.
 * 
 * @author Ignas Lelys
 * @created Jul 28, 2011
 * 
 */
public class ScapegoatTree extends AbstractSelfBalancingBinarySearchTree {

    /** Alpha parameter. */
    private double alpha = 0.57;
    
    private int maxSize = 0;
    
    /**
     * Constructor.
     */
    public ScapegoatTree() {
        super();
    }

    /**
     * Constructor.
     * 
     * @param alpha Alpha parameter.
     */
    public ScapegoatTree(double alpha) {
        super();
        this.alpha = alpha;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Node insert(int element) {
        Node inserted = super.insert(element);
        int height = getNodeHeight(inserted);
        if (height > getHAlpha()) {
            Node scapegoat = findScapegoatNode(inserted);
            Node scapegoatParent = scapegoat.parent;
            boolean scapegoatOnParentsLeft = scapegoatParent != null && scapegoatParent.left == scapegoat;
            Node rebuiltSubtree = rebuildTree(getSubtreeSize(scapegoat), scapegoat);
            rebuiltSubtree.parent = scapegoatParent;
            if (scapegoatParent != null) {
                if (scapegoatOnParentsLeft) {
                    scapegoatParent.left = rebuiltSubtree;
                } else {
                    scapegoatParent.right = rebuiltSubtree;
                }
            }
            if (scapegoat == root) {
                root = rebuiltSubtree;
            }
            maxSize = getSize();
        }
        return inserted;
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Node delete(int element) {
        Node replaceNode = super.delete(element);
        if (getSize() <= alpha * maxSize) {
            root = rebuildTree(getSize(), root);
            maxSize = getSize();
        }
        return replaceNode;
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    protected Node createNode(int value, Node parent, Node left, Node right) {
        return new Node(value, parent, left, right);
    }
    
    /**
     * Finds scapegoat node which is used for rebalancing the tree.
     * 
     * @return Scapegoat node.
     */
    protected Node findScapegoatNode(Node node) {
        int size = 1;
        int height = 0;
        int totalSize = 0;
        while (node.parent != null) {
            height++;
            totalSize = 1 + size + getSubtreeSize(getSibling(node));
            if (height > Math.floor(MathUtils.logarithm(1 / alpha, totalSize))) {
                return node.parent;
            }
            node = node.parent;
            size = totalSize;
        }
        return null;
    }

    /**
     * Rebuilds unbalanced tree.
     * Found this implementation much clearer and easier to make it work: https://github.com/satchamo/Scapegoat-Tree/blob/master/scapegoat.py
     * Could't get implementations from pdfs to work.
     * 
     * @param size Size of subtree.
     * @param scapegoat Scapegoat is the root of subtree of {@link size} number of nodes.
     * 
     * @return Balanced subtree.
     */
    protected Node rebuildTree(int size, Node scapegoat) {
        List<Node> nodes = new ArrayList<Node>();
        
        // flatten tree without recursion
        Node currentNode = scapegoat;
        boolean done = false;
        Stack<Node> stack = new Stack<>();
        while (!done) {
            if (currentNode != null) {
                stack.push(currentNode);
                currentNode = currentNode.left;
            } else {
                if (!stack.isEmpty()) {
                    currentNode = stack.pop();
                    nodes.add(currentNode);
                    currentNode = currentNode.right;
                } else {
                    done = true;
                }
            }
        }
        
        // build tree from flattened list of nodes
        return buildTree(nodes, 0, size - 1);
    }
    
    /**
     * Build balanced tree from flattened tree.
     */
    private Node buildTree(List<Node> nodes, int start, int end) {
        int middle = (int)Math.ceil(((double)(start + end)) / 2.0);
        if (start > end) {
            return null;
        }

        // middle becomes root of subtree instead of scapegoat
        Node node = nodes.get(middle);
        
        // recursively get left and right nodes
        Node leftNode = buildTree(nodes, start, middle - 1);
        node.left = leftNode;
        if (leftNode != null) {
            leftNode.parent = node;
        }
        Node rightNode = buildTree(nodes, middle + 1, end);
        node.right = rightNode;
        if (rightNode != null) {
            rightNode.parent = node;
        }
        return node;
    }
    
    /**
     * @return Node's sibling.
     */
    // TODO move to AbstractBinaySearchTree and use in other trees where needed.
    private Node getSibling(Node node) {
        if (node.parent != null) {
            if (node.parent.left == node) {
                return node.parent.right;
            } else {
                return node.parent.left;
            }
        }
        return null;
    }
    
    /**
     * Calculate size of subtree.
     * 
     * @param node
     *            Subtree root node.
     * @return Number of elements in the subtree.
     */
    // TODO move to AbstractBinaySearchTree
    protected int getSubtreeSize(Node node) {
        if (node == null) {
            return 0;
        }
        if (node.isLeaf()) {
            return 1;
        } else {
            int sum = 1;
            sum += getSubtreeSize(node.left);
            sum += getSubtreeSize(node.right);
            return sum;
        }
    }
    
    // TODO move to AbstractBinaySearchTree
    protected int getNodeHeight(Node node) {
        if (node == null) {
            return -1;
        } else if (node.parent == null) {
            return 0;
        } else {
            return getNodeHeight(node.parent) + 1;
        }
    }

    private int getHAlpha() {
        return (int)Math.floor(MathUtils.logarithm(1 / alpha, (double)getSize()));
    }

}
```



## 配对树

```java
package net.mooctest;

/**
 * 
 * @author juraj67
 * @param <T>
 */
public class Heap_Item <T extends Comparable<T>> {
    
    private Heap_Item ancestor;
    private Heap_Item leftSon;
    private Heap_Item rightSon;
    private T data;
    
    /**
     * Constructor creates an empty Heap_Item
     */
    public Heap_Item() {
    }
    
    /**
     * Constructor creates a new Heap_Item
     * @param data 
     */
    public Heap_Item(T data) {
        this.data = data;
    }
    
    /**
     * Copy constructor makes a copy of Heap_Item
     * @param paCopy_HeapItem 
     */
    public Heap_Item(Heap_Item<T> paCopy_HeapItem) {
        this.leftSon = paCopy_HeapItem.getLeftSon();
        this.rightSon = paCopy_HeapItem.getRightSon();
        this.data = paCopy_HeapItem.getData();
        this.ancestor = paCopy_HeapItem.getAncestor();
    }

    /**
     * Method returns the ancestor in binary form
     */
    public Heap_Item<T> getAncestor() {
        return ancestor;
    }
    
    /**
     * Method sets the ancestor of the heap (in binary form)
     * @param ancestor 
     */
    public void setAncestor(Heap_Item ancestor) {
        this.ancestor = ancestor;
    }
    
    /**
     * Method returns the ancestor of the multi-way pairing heap
     * @return 
     */
    public Heap_Item<T> getMultiWayAncestor() {
        if(this.ancestor != null) {
            if(this.ancestor.itIsLeftSon(this)) {
                return this.ancestor;
            } else {
                Heap_Item<T> node = this.ancestor;
                while(!node.getAncestor().itIsLeftSon(node)) {
                    node = node.getAncestor();
                }
                return node.getAncestor();
            }
        }
        return null;
    }
    
    /**
     * Method returns the left son of heap
     * @return 
     */
    public Heap_Item<T> getLeftSon() {
        return this.leftSon;
    }
    
    /**
     * Method returns the right son of heap
     * @return 
     */
    public Heap_Item<T> getRightSon() {
        return this.rightSon;
    }
    
    /**
     * Method returns heap data
     * @return 
     */
    public T getData() {
        return (this.data == null ? null : this.data);
    }
    
    /**
     * Method sets the heap data
     * @param data 
     */
    public void setData(T data) {
        this.data = data;
    }
    
    /**
     * Set left son of the heap 
     * @param leftSon 
     */
    public void setLeftSon(Heap_Item leftSon) {
        this.leftSon = leftSon;
    }
    
    /**
     * Set right son of the heap 
     * @param rightSon 
     */
    public void setRightSon(Heap_Item rightSon) {
        this.rightSon = rightSon;
    }
    
    /**
     * Method returns true if the heap has a left son
     * @return 
     */
    public boolean hasLeftSon() {
        return (this.leftSon != null);
    }
    
    /**
     * Method returns true if the heap has a right son
     * @return 
     */
    public boolean hasRightSon() {
        return (this.rightSon != null);
    }
    
    /**
     * Method removes the left son from the heap
     */
    public void removeLeftSon() {
        this.leftSon = null;
    }
    
    /**
     * Method removes the right son from the heap
     */
    public void removeRightSon() {
        this.rightSon = null;
    }
    
    /**
     * Method returns an item that matches the criteria
     * @param paCriterion
     * @return 
     */
    public Heap_Item<T> getSonByData(T paCriterion) {
        if(this.hasLeftSon() && this.leftSon.getData().compareTo(paCriterion) == 0) {
            return this.leftSon;
        } else if(this.hasRightSon() && this.rightSon.getData().compareTo(paCriterion) == 0) {
            return this.rightSon;
        } else {
            return null;
        }
    }
    
    /**
     * Method removes an item that matches the criteria
     * @param paCriterion 
     */
    public void removeChild(T paCriterion) {
        if(this.hasLeftSon() && this.leftSon.getData().compareTo(paCriterion) == 0) {
            this.leftSon = null;
            return;
        } 
        if(this.hasRightSon() && this.rightSon.getData().compareTo(paCriterion) == 0) {
            this.rightSon = null;
            return;
        }
    }
    
    /**
     * Method returns true, if the parameter matches the left son of the heap
     * @param paNode
     * @return 
     */
    public boolean itIsLeftSon(Heap_Item<T> paNode) {
        return (this.leftSon == paNode ? true : false);
    }
    
    /**
     * Method replaces a son who meets the criteria
     * @param paCriterion
     * @param paNode
     * @return 
     */
    public boolean replaceChild(T paCriterion, Heap_Item<T> paNode) {
        if(this.hasLeftSon() && this.leftSon.getData().compareTo(paCriterion) == 0) {
            this.leftSon = paNode;
            return true;
        } else if(this.hasRightSon()&& this.rightSon.getData().compareTo(paCriterion) == 0){
            this.rightSon = paNode;
            return true;
        } else { 
            return false;
        }
    }
}
```

```java
package net.mooctest;

import java.util.Queue;
import java.util.LinkedList;

/**
 *
 * @author juraj67
 * @param <T>
 */
public class Pairing_Heap <T extends Comparable<T>>  {
    
    private Heap_Item<T> root;
    
    /**
     * Constructor creates an empty Pairing_Heap
     */
    public Pairing_Heap() {
    }
    
    /**
     * Constructor creates new Pairing_Heap with root
     * @param root 
     */
    public Pairing_Heap(Heap_Item<T> root) {
        this.root = root;
    }
    
    /**
     * Copy constructor makes a copy of Pairing_Heap
     * @param heap_toCopy 
     */
    public Pairing_Heap(Pairing_Heap<T> heap_toCopy) {
        this.root = heap_toCopy.getRoot();
    }
        
    /**
     * Method returns the root of the pairing heap
     * @return 
     */
    public Heap_Item<T> getRoot() {
        return this.root;
    }
    
    /**
     * Method returns the root data
     * @return 
     */
    public T peek() {
        return this.root.getData();
    }
    
    /**
     * Method inserts a new heap item into the pairing heap
     * @param to_insert
     * @return 
     */
    public Heap_Item<T> push(Heap_Item<T> to_insert) {
        if(this.root == null) {
            this.root = to_insert;
            return this.root;
        } else {
            this.root = pair(this, new Pairing_Heap(to_insert)).getRoot();
            return to_insert;
        }
    }
    
    /**
     * Method removes the root of the pairing heap and also returns heap data
     * @return 
     */
    public T pop() {
        return (this.root == null) ? null : this.pop_heap_item().getData();
    }
    
    /**
     * Method removes the root of the pairing heap, finds the new root and returns the heap item
     * @return 
     */
    private Heap_Item<T> pop_heap_item() {
        if(this.root == null) {                                  //if the heap is empty
            return null;
        } else {
            Heap_Item<T> old_root = this.root;
            this.root = null;
            if(!old_root.hasLeftSon()) {                    //if the heap contains only the root
                return old_root;
            } else {                                        //if the heap contains more items
                if(!old_root.getLeftSon().hasRightSon()) {  //if the heap consists of one heap 
                    old_root.getLeftSon().setAncestor(null);
                    this.root = old_root.getLeftSon();
                    return old_root;
                } else {                                    //if the heap consists of multiple heaps
                    Heap_Item<T> help_item = old_root.getLeftSon();
                    help_item.setAncestor(null);
                    this.root = multi_heaps_merge(help_item).getRoot(); //returns the heap and sets root
                    return old_root;
                }
            }
        }
    }
    
    /**
     * Multi-pass pairing heap
     * Method pairs all heaps that remain after the root has been removed
     * @param paLeftSonOfRoot
     * @return 
     */
    private Pairing_Heap<T> multi_heaps_merge(Heap_Item paLeftSonOfRoot) {
        Queue<Pairing_Heap<T>> fifo = new LinkedList<>();
        
        //fills the queue with all heaps
        Heap_Item<T> help_item = null;
        do {  
            help_item = paLeftSonOfRoot.getRightSon();
            paLeftSonOfRoot.removeRightSon();
            paLeftSonOfRoot.setAncestor(null);
            if(paLeftSonOfRoot.hasLeftSon()) {
                paLeftSonOfRoot.getLeftSon().setAncestor(paLeftSonOfRoot);
            }
            fifo.add(new Pairing_Heap<>(paLeftSonOfRoot));
            paLeftSonOfRoot = help_item;
        } while(help_item != null);
        
        //pairs two heaps and put them in a queue until only one heap is in queue
        while(fifo.size() != 1) {
            fifo.add(pair(fifo.remove(),fifo.remove()));
        }
        //returns last pairing heap that remains in the queue
        return fifo.remove();   
    }
    
    
    
    /**
     * Method pairs two pairing heaps
     * @param paHeap1
     * @param paHeap2
     * @return
     */
    private Pairing_Heap<T> pair(Pairing_Heap<T> paHeap1, Pairing_Heap<T> paHeap2) {
        if(paHeap1.getRoot() == null) {
            return paHeap2;
        } 
        if(paHeap2.getRoot() == null) {
            return paHeap1;
        } 
        if(paHeap1.getRoot().getData().compareTo(paHeap2.getRoot().getData()) <= 0) { //if 2 has a worse priority then 1
            if(paHeap1.getRoot().hasLeftSon()) {
                Heap_Item<T> help_item = paHeap1.getRoot().getLeftSon();
                paHeap1.getRoot().setLeftSon(paHeap2.getRoot());
                paHeap2.getRoot().setAncestor(paHeap1.getRoot());
                paHeap2.getRoot().setRightSon(help_item);
                help_item.setAncestor(paHeap2.getRoot());
                return paHeap1;
            } else {
                paHeap1.getRoot().setLeftSon(paHeap2.getRoot());
                paHeap2.getRoot().setAncestor(paHeap1.getRoot());
                return paHeap1;
            }
        } else {                                                                //if 2 has a better priority then 1
            if(paHeap2.getRoot().hasLeftSon()) {
                Heap_Item<T> help_item = paHeap2.getRoot().getLeftSon();
                paHeap2.getRoot().setLeftSon(paHeap1.getRoot());
                paHeap1.getRoot().setAncestor(paHeap2.getRoot());
                paHeap1.getRoot().setRightSon(help_item);
                help_item.setAncestor(paHeap1.getRoot());
                return paHeap2;
            } else {
                paHeap2.getRoot().setLeftSon(paHeap1.getRoot());
                paHeap1.getRoot().setAncestor(paHeap2.getRoot());
                return paHeap2;
            }
        }
    }
    
    /**
     * Method checks if the positions of the items are correct after the priority change
     * @param paNode 
     */
    public void checkPriority(Heap_Item<T> paNode) {
        //increasing - checking if the paNode has better priority as his ancestor in multi-way form
        if(paNode.getAncestor() != null && paNode.getMultiWayAncestor().getData().compareTo(paNode.getData()) > 0) {
            paNode.getAncestor().replaceChild(paNode.getData(), null);                  //removes item from heap
            paNode.setAncestor(null);
            if(paNode.hasRightSon()) { 
                paNode = this.multi_heaps_merge(paNode).getRoot();
            }
            this.root = this.pair(this, new Pairing_Heap(paNode)).getRoot();               //pairing with root 
            return;
        }
        //decreasing - checking if the paNode has a worse priority then his sons in multi-way form
        if(paNode.hasLeftSon()) {
            Heap_Item<T> son_of_node = paNode.getLeftSon();
            do {
                if(paNode.getData().compareTo(son_of_node.getData()) > 0) {
                    son_of_node = paNode.getLeftSon();
                    paNode.removeLeftSon();                                             //removes all sons from heap
                    son_of_node.setAncestor(null);
                    Pairing_Heap<T> merged_heap = this.multi_heaps_merge(son_of_node);  //merging sons

                    Heap_Item<T> right_sonof_node = paNode.getRightSon();          
                    Heap_Item<T> anchestor_of_node = paNode.getAncestor();
                    if(right_sonof_node != null) {
                        right_sonof_node.setAncestor(null);
                        paNode.removeRightSon();
                    }
                    merged_heap = this.pair(merged_heap, new Pairing_Heap(paNode));     //pairs and sets new root
                    //puts a new subtree with a new root at the originally location 
                    if(anchestor_of_node != null) {                                     //if the item was root
                        anchestor_of_node.replaceChild(paNode.getData(),merged_heap.getRoot());
                        merged_heap.getRoot().setRightSon(right_sonof_node);                 
                        merged_heap.getRoot().setAncestor(anchestor_of_node);
                        if(right_sonof_node != null) {                                  //if the item has right son
                            right_sonof_node.setAncestor(merged_heap.getRoot());
                        }
                    } else {
                        this.root = merged_heap.getRoot();
                    }
                    break;
                }
                son_of_node = son_of_node.getRightSon();
            } while(son_of_node != null);
        }
    } 
}

```

# 图

---

> 数据结构中的元素存在多对多的相互关系



##	邻接矩阵





##	邻接表

```c++
//
// Created by LeK on 2022/10/30.
//
//邻接表

#include "stdlib.h"
#include <iostream>

#define Status int
#define OK 1
#define ERROR 0
#define VertexType char

using namespace std;

typedef struct ArcNode {
    int adjvex; //该弧所指向的顶点的位置
    struct ArcNode *nextarc;    //指向下一条弧的指针
} ArcNode;

typedef struct VNode {
    VertexType data;    //顶点信息
    ArcNode *firstarc;  //指向第一条以该顶点为尾的弧的指针
} VNode, *AdjList;

typedef struct {
    AdjList vertices;   //头结点数组
    int vexnum, arcnum;  //图的当前顶点数和弧数
    int kind;   //图的种类标志
} ALGraph;

Status CreatAdjList(ALGraph &G) {
    int j, t;
    char ch, vj, vt;
    ArcNode *arc, *p;
    G.vertices = (AdjList) calloc(G.vexnum , sizeof(VNode));    //头结点数组
    cout<<"输入顶点序列：";
    for (int i = 0; i < G.vexnum; ++i) {    //顶点数据
        cin>>ch;
        G.vertices[i].data = ch;
    }
    cout<<"输入弧偶对：\n";
    for (int i = 0; i < G.arcnum; ++i) {    //输入弧
        cin>>vj>>vt;
        j = t = 0;
        while (G.vertices[j].data != vj) j++;   //弧尾顶点索引
        while (G.vertices[t].data != vt) t++;   //弧头顶点索引
        p = G.vertices[j].firstarc;
        if (!p) {
            arc = (ArcNode *) malloc(sizeof(ArcNode));
            arc->adjvex = t;
            arc->nextarc = NULL;
            G.vertices[j].firstarc = arc;
        } else {
            while (p->nextarc) p = p->nextarc;
            arc = (ArcNode *) malloc(sizeof(ArcNode));
            arc->adjvex = t;
            arc->nextarc = NULL;
            p->nextarc = arc;
        }
    }
    return OK;
}

Status Display(ALGraph G) {
    ArcNode *p;
    for (int i = 0; i < G.vexnum; ++i) {
        p = G.vertices[i].firstarc;
        if (!p) {
            printf("NULL\n");
        } else {
            while (p) {
                printf("%d ", p->adjvex);
                p = p->nextarc;
            }
            printf("\n");
        }
    }
    return OK;
}

int main() {
    ALGraph G;
    cout<<"输入顶点数和弧数：";
    cin>>G.vexnum>>G.arcnum;
    printf("\n");
    CreatAdjList(G);
    Display(G);
    return 0;
}
```



##	最短路径

### Dijkstra算法

一个源点到所有顶点的最短路径

```c++
//
// Created by LeK on 2022/11/6.
//
//Dijkstra算法

#include <stdio.h>
#include <stdlib.h>
#include <iostream>

using namespace std;

#define Status int
#define OK 1
#define ERROR 0
#define INFINITY 10000
#define MAX_VERTEX_NUM 20   //最大顶点数
#define VRType int
#define InfoType int
#define VertexType char

typedef enum {
    DG, DN, UDG, UDN    //有向图，有向网，无向图，无向网
} GraphKind;

typedef struct ArcCell {
    VRType adj; //顶点关系类型，对无权图用1或0，对有权图为权值
    InfoType *info; //该弧相关信息的指针
} ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];   //邻接矩阵

typedef struct Node {
    VRType D;   //路径长度
    int parent;  //路径上一个结点
} Node, Nodes[MAX_VERTEX_NUM];

typedef struct {
    VertexType vexs[MAX_VERTEX_NUM];    //顶点向量
    AdjMatrix arcs; //邻接矩阵
    Nodes Node; //顶点结点
    int vexnum, arcnum; //顶点数和弧数
    GraphKind kind; //图的种类标志
} MGraph;

int LocateVex(MGraph G, VertexType v) { //获取顶点索引
    for (int i = 0; i < G.vexnum; i++)
        if (v == G.vexs[i]) return i;
}

bool check(MGraph G, int *final) {  //检查是否所有顶点都已进入路径
    for (int i = 0; i < G.vexnum; ++i) {
        if (!final[i]) return false;
    }
    return true;
}

void ShortestPath_DIJ(MGraph &G, VertexType v) {
    int final[MAX_VERTEX_NUM];
    int v0 = LocateVex(G, v);
    int min, parent;
    for (int i = 0; i < MAX_VERTEX_NUM; i++) final[i] = 0;
    G.Node[v0].D = 0;
    G.Node[v0].parent = -1;
    final[v0] = 1;
    for (int i = 1; i < G.vexnum; ++i) {    //每进行一次都至少将一个顶点放入路径
        if (check(G, final)) break;
        for (int j = 1; j < G.vexnum; ++j) {    //遍历查找可放入路径的顶点
            min = INFINITY;
            parent = -1;
            for (int k = 0; k < G.vexnum; ++k) {    //寻找k为尾，j为头的弧
                if (k == j) continue;
                if (final[k] && (G.Node[k].D + G.arcs[k][j].adj) < min) {
                    min = G.Node[k].D + G.arcs[k][j].adj;
                    parent = k;
                    final[j] = 1;
                }
            }
            G.Node[j].D = min;
            G.Node[j].parent = parent;
        }
    }
}

Status CreateDN(MGraph &G) {
    int IncInfo, w, i, j;
    VertexType v1, v2;
    printf("输入顶点数，边数，边的其他信息（若无则输入0）:");
    scanf("%d %d %d", &G.vexnum, &G.arcnum, &IncInfo);
    printf("请输入顶点：");
    for (i = 0; i < G.vexnum; i++)
        cin >> G.vexs[i];
    for (i = 0; i < G.vexnum; i++)
        for (j = 0; j < G.vexnum; j++) {
            G.arcs[i][j].adj = INFINITY;
            G.arcs[i][j].info = 0;
        }
    printf("输入顶点有序对与权值：\n");
    for (int k = 0; k < G.arcnum; k++) {

        cin >> v1 >> v2 >> w;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j].adj = w;
        if (IncInfo) scanf("%d", G.arcs[i][j].info);
    }
    G.kind = DN;
    return OK;
}

void display_path(MGraph G, int parent) {
    if (parent != -1) {
        display_path(G, G.Node[parent].parent);
        if (G.Node[parent].D != INFINITY)
            printf("%c ", G.vexs[parent]);
        else printf("无");
    }

}

Status main() {
    MGraph G;
    VertexType v0;
    CreateDN(G);
    printf("输入起始顶点：");
    cin >> v0;
    ShortestPath_DIJ(G, v0);
    for (int i = 0; i < G.vexnum; ++i) {
        printf("%c顶点到%c顶点路径为：", v0, G.vexs[i]);
        display_path(G, i);
        if (G.Node[i].D != INFINITY)
            printf("\t路径长度为：%d", G.Node[i].D);
        printf("\n");
    }
    return OK;
}

/*
输入顶点数，边数，边的其他信息（若无则输入0）:6 8 0
请输入顶点：ABCDEF
输入顶点有序对与权值：
A C 10
A E 30
A F 100
B C 5
C D 50
D F 10
E D 20
E F 60
输入起始顶点：A
A顶点到A顶点路径为：A     路径长度为：0
A顶点到B顶点路径为：无
A顶点到C顶点路径为：A C         路径长度为：10
A顶点到D顶点路径为：A E D       路径长度为：50
A顶点到E顶点路径为：A E         路径长度为：30
A顶点到F顶点路径为：A E D F     路径长度为：60
*/

void DiJ(MGraph G, int v0, PathMatrix &P, ShortPathTable &D) {
    for (v = 0; v < G.vexnum; ++v) {
        final[v0] = FALSE;
        D[v] = G.arcs[v0][v];
        for (w = 0; w < G.vexnum; ++w)
            P[v][w] = FALSE;
        if (D[v] < INFINITY) {
            P[v][v0] = TRUE;
            P[v][v] = TRUE;
        }
    }
    for (i = 1; i < G.vexnum; ++i) {
        min = INFINITY;
        for (w = 0; w < G.vexnum; ++w) {
            if (!final[w])
                if (D[w] < min) {
                    v = w;
                    min = D[w];
                }
        }
        final[v] = TRUE;
        for (int w = 0; w < G.vewnum; ++w) {
            if(!final[w]&&(min+G.arcs[v][w]<D[w])){
                D[w] = min+G.arcs[v][w];
                P[w] = P[v];
                P[w][w] = TRUE;
            }
        }
    }
}
```



### Floyd算法

任意两个顶点间的最短路径

```C++
void ShortestPath_Floyd(MGraph &G,int **&Path) {
    int i,j,v;
    for (int i = 0; i < G.vexnum; ++i) {
        for (int j = 0; j < G.vexnum; ++j) {
            Path[i][j]=-1;
        }
    }
    for (v = 0; v < G.vexnum; ++v) {
        for (i = 0; i < G.vexnum; ++i) {
            for (j = 0; j < G.vexnum; ++j) {
                if (G.arcs[i][j].adj>G.arcs[i][v].adj+G.arcs[v][j].adj){
                    G.arcs[i][j].adj = G.arcs[i][v].adj+G.arcs[v][j].adj;
                    Path[i][j] = v;
                }
            }
        }
    }
}

void display_path(MGraph G,VertexType u,VertexType v,int **path) {
    int u0 = LocateVex(G,u);
    int v0 = LocateVex(G,v);
    if (path[u0][v0] == -1 && G.arcs[u0][v0].adj==INFINITY)
        printf("可惜捏，到不了捏");
    else if (path[u0][v0]==-1) printf("<%c,%c> ",G.vexs[u0],G.vexs[v0]);
    else{
        int mid = path[u0][v0];
        display_path(G,u,G.vexs[mid],path);
        display_path(G,G.vexs[mid],v,path);
    }

}
```





#	查找

二分查找

```C++
int binary_search(int array[], int low, int high, int x) {
    int mid = (low + high) / 2;
    if (low > high) return -1;
    if (array[low] == x) return low;
    if (array[high] == x) return high;
    if (array[mid] == x) return mid;
    else if (array[mid] < x) binary_search(array, mid + 1, high, x);
    else if (array[mid] > x) binary_search(array, low, mid - 1, x);
}
```





# topk

```C
//
// Created by LeK on 2022/12/9.
//

#include "stdio.h"
#include "stdlib.h"

#define ElemType int
#define SqList int*
#define MAXNUM 100

void Display(SqList L, int n) {
    for (int i = 1; i <= n; ++i) {
        printf("%d ", L[i]);
    }
    printf("\n");
}

void sift(SqList&final, int start, int end) {   //调整
    int i = start, j = 2 * i;
    ElemType tmp = final[start];
    while (j <= end) {
        if (final[j] < final[j + 1] && (j + 1) <= end)
            j = j + 1;
        if (final[j] > tmp) {
            final[i] = final[j];
            i = j;
            j = 2 * i;
        } else {
            break;
        }
    }
    final[i] = tmp;
}


void HeapFind(SqList&L, SqList&final, int n, int k) {
    ElemType tmp;
    for (int i = k+1; i <=n; ++i) {
        if(L[i] <final[1] ) {
            final[1] = L[i];
            sift(final,1,k);
        }
    }
}

void HeapSort(SqList&L, int n) {
    ElemType tmp;
    for (int i = n / 2; i >= 1; --i) {
        sift(L, i, n);
    }
}

int main() {
    SqList arr;
    SqList final;
    int n, k;
    arr = (SqList) calloc(MAXNUM, sizeof(ElemType));
    printf("输入总的元素个数:");
    scanf("%d", &n);
    printf("输入元素:\n");
    for (int i = 0; i < n; ++i)
        scanf("%d", &arr[i + 1]);
    printf("输入需要的最小元素个数:");
    scanf("%d", &k);
    final = (SqList) calloc(k + 1, sizeof(ElemType));
    for (int i = 0; i < k; ++i)
        final[i + 1] = arr[i + 1];
    HeapSort(final, k);
    HeapFind(arr, final, n, k);

    printf("前%d个最小元素为:",k);
    Display(final, k);

    return 0;
}

```





# 棋盘覆盖

```c++
//
// Created by LeK on 2023/3/12.
//

#include<iostream>

using namespace std;
int tile = 1;                   //L型骨牌的编号(递增)
int board[100][100];  //棋盘
/*****************************************************
* 递归方式实现棋盘覆盖算法
* 输入参数：
* tr--当前棋盘左上角的行号
* tc--当前棋盘左上角的列号
* dr--当前特殊方格所在的行号
* dc--当前特殊方格所在的列号
* size：当前棋盘的:2^k
*****************************************************/
void chessBoard(int tr, int tc, int dr, int dc, int size) {
    if (size == 1)    //棋盘方格大小为1,说明递归到最里层
        return;
    int t = tile++;     //每次递增1
    int s = size / 2;    //棋盘中间的行、列号(相等的)
    //检查特殊方块是否在左上角子棋盘中
    if (dr < tr + s && dc < tc + s)              //在
        chessBoard(tr, tc, dr, dc, s);
    else         //不在，将该子棋盘右下角的方块视为特殊方块
    {
        board[tr + s - 1][tc + s - 1] = t;
        chessBoard(tr, tc, tr + s - 1, tc + s - 1, s);
    }
    //检查特殊方块是否在右上角子棋盘中
    if (dr < tr + s && dc >= tc + s)               //在
        chessBoard(tr, tc + s, dr, dc, s);
    else          //不在，将该子棋盘左下角的方块视为特殊方块
    {
        board[tr + s - 1][tc + s] = t;
        chessBoard(tr, tc + s, tr + s - 1, tc + s, s);
    }
    //检查特殊方块是否在左下角子棋盘中
    if (dr >= tr + s && dc < tc + s)              //在
        chessBoard(tr + s, tc, dr, dc, s);
    else            //不在，将该子棋盘右上角的方块视为特殊方块
    {
        board[tr + s][tc + s - 1] = t;
        chessBoard(tr + s, tc, tr + s, tc + s - 1, s);
    }
    //检查特殊方块是否在右下角子棋盘中
    if (dr >= tr + s && dc >= tc + s)                //在
        chessBoard(tr + s, tc + s, dr, dc, s);
    else         //不在，将该子棋盘左上角的方块视为特殊方块
    {
        board[tr + s][tc + s] = t;
        chessBoard(tr + s, tc + s, tr + s, tc + s, s);
    }
}

void main() {
    int size;
    int index_x, index_y;
    cout << "输入棋盘的边长(2的k次幂): ";
    cin >> size;
    cout << "输入特殊方格位置的坐标: ";
    cin >> index_x >> index_y;
    chessBoard(0, 0, index_x - 1, index_y - 1, size);
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++)
            cout << board[i][j] << "\t";
        cout << endl;
    }
}
```



# 蚁群算法

```java
import java.util.ArrayList;

/**
 * 蚂蚁类，进行路径搜索的载体
 * 
 * @author lyq
 * 
 */
public class Ant implements Comparable<Ant> {
	// 蚂蚁当前所在城市
	String currentPos;
	// 蚂蚁遍历完回到原点所用的总距离
	Double sumDistance;
	// 城市间的信息素浓度矩阵，随着时间的增多而减少
	double[][] pheromoneMatrix;
	// 蚂蚁已经走过的城市集合
	ArrayList<String> visitedCitys;
	// 还未走过的城市集合
	ArrayList<String> nonVisitedCitys;
	// 蚂蚁当前走过的路径
	ArrayList<String> currentPath;

	public Ant(double[][] pheromoneMatrix, ArrayList<String> nonVisitedCitys) {
		this.pheromoneMatrix = pheromoneMatrix;
		this.nonVisitedCitys = nonVisitedCitys;

		this.visitedCitys = new ArrayList<String>();
		this.currentPath = new ArrayList<String>();
	}

	/**
	 * 计算路径的总成本(距离)
	 * 
	 * @return
	 */
	public double calSumDistance() {
		sumDistance = 0.0;
		String lastCity;
		String currentCity;

		for (int i = 0; i < currentPath.size() - 1; i++) {
			lastCity = currentPath.get(i);
			currentCity = currentPath.get(i + 1);

			// 通过距离矩阵进行计算
			sumDistance += ACO.disMatrix[Integer.parseInt(lastCity)][Integer
					.parseInt(currentCity)];
		}

		return sumDistance;
	}

	/**
	 * 蚂蚁选择前往下一个城市
	 * 
	 * @param city
	 *            所选的城市
	 */
	public void goToNextCity(String city) {
		this.currentPath.add(city);
		this.currentPos = city;
		this.nonVisitedCitys.remove(city);
		this.visitedCitys.add(city);
	}

	/**
	 * 判断蚂蚁是否已经又重新回到起点
	 * 
	 * @return
	 */
	public boolean isBack() {
		boolean isBack = false;
		String startPos;
		String endPos;

		if (currentPath.size() == 0) {
			return isBack;
		}

		startPos = currentPath.get(0);
		endPos = currentPath.get(currentPath.size() - 1);
		if (currentPath.size() > 1 && startPos.equals(endPos)) {
			isBack = true;
		}

		return isBack;
	}

	/**
	 * 判断蚂蚁在本次的走过的路径中是否包含从城市i到城市j
	 * 
	 * @param cityI
	 *            城市I
	 * @param cityJ
	 *            城市J
	 * @return
	 */
	public boolean pathContained(String cityI, String cityJ) {
		String lastCity;
		String currentCity;
		boolean isContained = false;

		for (int i = 0; i < currentPath.size() - 1; i++) {
			lastCity = currentPath.get(i);
			currentCity = currentPath.get(i + 1);

			// 如果某一段路径的始末位置一致，则认为有经过此城市
			if ((lastCity.equals(cityI) && currentCity.equals(cityJ))
					|| (lastCity.equals(cityJ) && currentCity.equals(cityI))) {
				isContained = true;
				break;
			}
		}

		return isContained;
	}

	public int compareTo(Ant o) {
		// TODO Auto-generated method stub
		return this.sumDistance.compareTo(o.sumDistance);
	}
}

```

```java
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

/**
 * 蚁群算法工具类
 * 
 * @author lyq
 * 
 */
public class ACO {
	// 输入数据类型
	public static final int INPUT_CITY_NAME = 1;
	public static final int INPUT_CITY_DIS = 2;

	// 城市间距离邻接矩阵
	public static double[][] disMatrix;
	// 当前时间
	public static int currentTime;

	// 测试数据地址
	private String filePath;
	// 蚂蚁数量
	private int antNum;
	// 控制参数
	private double alpha;
	private double beita;
	private double p;
	private double Q;
	// 随机数产生器
	private Random random;
	// 城市名称集合,这里为了方便，将城市用数字表示
	private ArrayList<String> totalCitys;
	// 所有的蚂蚁集合
	private ArrayList<Ant> totalAnts;
	// 城市间的信息素浓度矩阵，随着时间的增多而减少
	private double[][] pheromoneMatrix;
	// 目标的最短路径,顺序为从集合的前部往后挪动
	private ArrayList<String> bestPath;
	// 信息素矩阵存储图,key采用的格式(i,j,t)->value
	private Map<String, Double> pheromoneTimeMap;

	public ACO(ArrayList<String[]> dataArray, int antNum, double alpha, double beita,
			double p, double Q) {
		this.antNum = antNum;
		this.alpha = alpha;
		this.beita = beita;
		this.p = p;
		this.Q = Q;
		this.currentTime = 0;

		readDataFile(dataArray);
	}

	/**
	 * 读取数据
	 */
	private void readDataFile(ArrayList<String[]> dataArray) {

		int flag = -1;
		int src = 0;
		int des = 0;
		int size = 0;
		// 进行城市名称种数的统计
		this.totalCitys = new ArrayList<String>();
		for (String[] array : dataArray) {
			if (array[0].equals("#") && totalCitys.size() == 0) {
				flag = INPUT_CITY_NAME;

				continue;
			} else if (array[0].equals("#") && totalCitys.size() > 0) {
				size = totalCitys.size();
				// 初始化距离矩阵
				this.disMatrix = new double[size + 1][size + 1];
				this.pheromoneMatrix = new double[size + 1][size + 1];

				// 初始值-1代表此对应位置无值
				for (int i = 0; i < size; i++) {
					for (int j = 0; j < size; j++) {
						this.disMatrix[i][j] = -1;
						this.pheromoneMatrix[i][j] = -1;
					}
				}

				flag = INPUT_CITY_DIS;
				continue;
			}

			if (flag == INPUT_CITY_NAME) {
				this.totalCitys.add(array[0]);
			} else {
				src = Integer.parseInt(array[0]);
				des = Integer.parseInt(array[1]);

				this.disMatrix[src][des] = Double.parseDouble(array[2]);
				this.disMatrix[des][src] = Double.parseDouble(array[2]);
			}
		}
	}

	/**
	 * 计算从蚂蚁城市i到j的概率
	 * 
	 * @param cityI
	 *            城市I
	 * @param cityJ
	 *            城市J
	 * @param currentTime
	 *            当前时间
	 * @return
	 */
	private double calIToJProbably(String cityI, String cityJ, int currentTime) {
		double pro = 0;
		double n = 0;
		double pheromone;
		int i;
		int j;

		i = Integer.parseInt(cityI);
		j = Integer.parseInt(cityJ);

		pheromone = getPheromone(currentTime, cityI, cityJ);
		n = 1.0 / disMatrix[i][j];

		if (pheromone == 0) {
			pheromone = 1;
		}

		pro = Math.pow(n, alpha) * Math.pow(pheromone, beita);

		return pro;
	}

	/**
	 * 计算综合概率蚂蚁从I城市走到J城市的概率
	 * 
	 * @return
	 */
	public String selectAntNextCity(Ant ant, int currentTime) {
		double randomNum;
		double tempPro;
		// 总概率指数
		double proTotal;
		String nextCity = null;
		ArrayList<String> allowedCitys;
		// 各城市概率集
		double[] proArray;

		// 如果是刚刚开始的时候，没有路过任何城市，则随机返回一个城市
		if (ant.currentPath.size() == 0) {
			nextCity = String.valueOf(random.nextInt(totalCitys.size()) + 1);

			return nextCity;
		} else if (ant.nonVisitedCitys.isEmpty()) {
			// 如果全部遍历完毕，则再次回到起点
			nextCity = ant.currentPath.get(0);

			return nextCity;
		}

		proTotal = 0;
		allowedCitys = ant.nonVisitedCitys;
		proArray = new double[allowedCitys.size()];

		for (int i = 0; i < allowedCitys.size(); i++) {
			nextCity = allowedCitys.get(i);
			proArray[i] = calIToJProbably(ant.currentPos, nextCity, currentTime);
			proTotal += proArray[i];
		}

		for (int i = 0; i < allowedCitys.size(); i++) {
			// 归一化处理
			proArray[i] /= proTotal;
		}

		// 用随机数选择下一个城市
		randomNum = random.nextInt(100) + 1;
		randomNum = randomNum / 100;
		// 因为1.0是无法判断到的，,总和会无限接近1.0取为0.99做判断
		if (randomNum == 1) {
			randomNum = randomNum - 0.01;
		}

		tempPro = 0;
		// 确定区间
		for (int j = 0; j < allowedCitys.size(); j++) {
			if (randomNum > tempPro && randomNum <= tempPro + proArray[j]) {
				// 采用拷贝的方式避免引用重复
				nextCity = allowedCitys.get(j);
				break;
			} else {
				tempPro += proArray[j];
			}
		}

		return nextCity;
	}

	/**
	 * 获取给定时间点上从城市i到城市j的信息素浓度
	 * 
	 * @param t
	 * @param cityI
	 * @param cityJ
	 * @return
	 */
	private double getPheromone(int t, String cityI, String cityJ) {
		double pheromone = 0;
		String key;

		// 上一周期需将时间倒回一周期
		key = MessageFormat.format("{0},{1},{2}", cityI, cityJ, t);

		if (pheromoneTimeMap.containsKey(key)) {
			pheromone = pheromoneTimeMap.get(key);
		}

		return pheromone;
	}

	/**
	 * 每轮结束，刷新信息素浓度矩阵
	 * 
	 * @param t
	 */
	private void refreshPheromone(int t) {
		double pheromone = 0;
		// 上一轮周期结束后的信息素浓度，丛信息素浓度图中查找
		double lastTimeP = 0;
		// 本轮信息素浓度增加量
		double addPheromone;
		String key;

		for (String i : totalCitys) {
			for (String j : totalCitys) {
				if (!i.equals(j)) {
					// 上一周期需将时间倒回一周期
					key = MessageFormat.format("{0},{1},{2}", i, j, t - 1);

					if (pheromoneTimeMap.containsKey(key)) {
						lastTimeP = pheromoneTimeMap.get(key);
					} else {
						lastTimeP = 0;
					}

					addPheromone = 0;
					for (Ant ant : totalAnts) {
						if(ant.pathContained(i, j)){
							// 每只蚂蚁传播的信息素为控制因子除以距离总成本
							addPheromone += Q / ant.calSumDistance();
						}
					}

					// 将上次的结果值加上递增的量，并存入图中
					pheromone = p * lastTimeP + addPheromone;
					key = MessageFormat.format("{0},{1},{2}", i, j, t);
					pheromoneTimeMap.put(key, pheromone);
				}
			}
		}

	}

	/**
	 * 蚁群算法迭代次数
	 * @param loopCount
	 * 具体遍历次数
	 */
	public void antStartSearching(int loopCount) {
		// 蚁群寻找的总次数
		int count = 0;
		// 选中的下一个城市
		String selectedCity = "";

		pheromoneTimeMap = new HashMap<String, Double>();
		totalAnts = new ArrayList<Ant>();
		random = new Random();

		while (count < loopCount) {
			initAnts();

			while (true) {
				for (Ant ant : totalAnts) {
					selectedCity = selectAntNextCity(ant, currentTime);
					ant.goToNextCity(selectedCity);
				}

				// 如果已经遍历完所有城市，则跳出此轮循环
				if (totalAnts.get(0).isBack()) {
					break;
				}
			}

			// 周期时间叠加
			currentTime++;
			refreshPheromone(currentTime);
			count++;
		}

		// 根据距离成本，选出所花距离最短的一个路径
		Collections.sort(totalAnts);
		bestPath = totalAnts.get(0).currentPath;
		System.out.println(MessageFormat.format("经过{0}次循环遍历，最终得出的最佳路径：", count));
		System.out.print("entrance");
		for (String cityName : bestPath) {
			System.out.print(MessageFormat.format("-->{0}", cityName));
		}
	}

	/**
	 * 初始化蚁群操作
	 */
	private void initAnts() {
		Ant tempAnt;
		ArrayList<String> nonVisitedCitys;
		totalAnts.clear();

		// 初始化蚁群
		for (int i = 0; i < antNum; i++) {
			nonVisitedCitys = (ArrayList<String>) totalCitys.clone();
			tempAnt = new Ant(pheromoneMatrix, nonVisitedCitys);

			totalAnts.add(tempAnt);
		}
	}
}

```

