# **Python**

------

## 边边角角

###	特性

1. 解释型语言：无编译环节，需要解释器

2. 跨平台的计算机程序设计语言，支持Windows、Linux、Mac
3. 交互式语言：可以再命令提示符“>>>”后直接执行，比如cmd、Python源文件下的交互式命令行程序
4. 面向对象

###	安装目录下各文件作用

1. IDLE是python自带的集成开发环境，可以运行调试代码，编写代码并保存等等
2. Python3.x(64-bit)是交互式python环境，这里写的代码不能保存到文件中。命令提示符输入python就是运行了这个文件。
3. Python3.x Module docs打开可以看到本机已安装的各种python的包的信息。

### pip源

(例如：pip install -i xxx yyy)

1. 清华源：https://pypi.tuna.tsinghua.edu.cn/simple/
2. 阿里云源：https://mirrors.aliyun.com/pypi/simple/
3. 中国科技大学源：https://pypi.mirrors.ustc.edu.cn/simple/



##	编写规范

Python中采用PEP 8（Python Enhancement Proposal version 8）作为编写规范

**PEP 8：**

1. 每个import语句只导入一个模块
2. 不要在行尾添加分号"**;**",也不要用分号将两条命令放在同一行
3. 建议每行不超过80个字符，建议使用"**()**"将多行内容隐式连接而不采用反斜杠"\\"（除非是导入模块的语句过长或注释里的URL）
4. 使用必要的空行可以增强代码的可读性，一般在顶级定义之间空两行，方法定义之间空一行
5. 通常情况下，运算符两侧、函数参数之间、"**,**" 两侧建议用空格进行分隔
6. 尽量避免在循环中使用"+"和"+="运算符累加字符串

**生成器表达式为什么不叫生成器推导式：**

PEP 289 —— 生成器表达式 的最后给出了详细的备注，其中指出Raymond Hettinger起初提议使用“生成器推导式（generator comprehension）”一词，后来Peter Norvig提出了“累计显示（accumulation displays）”，后来Tim Peters推荐了“生成器表达式”这个名词。
Guido指出了核心原因：
推导式一开始属于“字面量显示（literal display）”这一概念。而生成器表达式不是一种显示（display）。
Matt Boehm后来找到了Tim Peters提出“生成器表达式”一词的邮件，其中讲述了一些细节：
首先，为什么会使用“推导式”（comprehension）一词？Tim在邮件中指出，这个词来源于集合论中的推导公理（Axiom of Comprehension），它指的是通过对另一个集合的元素应用某个谓词（predicate，即条件）而组成新的集合。这和向另一个序列中的元素应用某个条件从而生成列表的做法非常类似。
EarlGrey：我之前看到很多翻译为“解析”，看到这里才觉得“推导式”才是更准确的说法。
正如Guido所指出的，Python的设计者当时更注重的是显示，而不是条件。“显示”一词在这里意味着代码的语法看上和它将创建的数据结构很像。列表显示（列表推导式）看上去像一个列表。对于集合和字典显示来说，也是一样的道理。但是由于没有生成器字面量语法，因此根本就没有一个生成器显示可以进行对比，也就不存在生成器显示了。
在设计该功能的那封邮件中，“推导式”是“显示”的同义词，由于生成器没有显示，所以也不可能有推导式。
不过Time在他的邮件中也说到，推导式的奇妙之处在于条件。推导公理的核心则是谓语。也许是因为Python推导式中的条件是可选的，关注的焦点被转移到了显示方面。



##	命名规范

1. 模块、函数、类的属性、方法的命名尽量短且全部使用小写字母，可使用下划线分隔多个字母
2. 包名尽量短小且全部使用小写字母，不推荐使用下划线
3. 类名采用单词首字母大写的形式
3. 模块内部的类采用下划线加单词首字母大写的类名组成
3. 常量命名时全部使用大写字母，可以使用下划线
3. 以单下划线"_"开头的模块变量或者函数是受保护的，在使用from xx import *语句从模块导入时这些变量或者函数不能被导入
3. 以双下划线"__" 开头的代表类的私有成员
3. 以双下划线开头和结尾的代表 Python 里特殊方法专用的标识，如"\__init__()" 代表类的构造函数。



## Pycharm

https://www.bilibili.com/medialist/play/watchlater/BV1aN411o7Ei

### 快捷键

![](E:\Study Notes\Pictures\Pycharm快捷键1.png)

![image-20220204150042206](E:\Study Notes\Pictures\Pycharm快捷键2.png)

自动调整代码格式的快捷键，默认为	`Alt+Ctrl+L`

pycharm在执行后将光标移到执行界面窗口	`alt+4`



###	Debug

1. 断点所在代码行变蓝，意味着Pycharm程序进程已经到达断点处，但尚未执行断点所标记的代码
2. 步过：单步执行，在函数内遇到子函数时不会进入子函数内，而是将子函数整个执行完再停止，也就是把子函数整个作为一步
3. 步进：单步执行时，遇到子函数就进入并且继续单步执行(包括源代码函数)
4. 单步执行我的代码：在单步执行时，遇到子函数就进入并且继续单步执行，不会进入到源码中
5. 步出：跳出当前函数体
6. 评估表达式：计算表达式
7. 恢复程序：直接运行到下一断点处
8. debug错误：
   1. 关闭Pycharm，删除工程目录下的.idea文件夹并重启
   2. 删除所有的断点。可以点击下图所示的两个叠在一起的红色原点进行操作
   3. 点击Pycharm的File>>Invalidate Caches / Restart…，然后选择Invalidate and Restart。这个操作清空了项目中的缓存信息
   4. 重建整个工程并重新配置

### TODO

待完成代码，类似C的空函数占位

eg：#	TODO（“xxx”）

###	创建虚拟环境意义

如果把包安装在解释器源文件夹中，假设做项目A，用的包版本要是selenium2.48.0 和 lxml=1.0.0，做项目B 必须用包版本是selenium2.50.0 和 lxml =1.2.0，那就要把selenium2.48.0 和 lxml=1.0.0卸载了并安装selenium2.50.0 和 lxml =1.2.0，但是这样换做类似项目A的包版本要求又得把以前的卸载了，装回selenium2.48.0 和 lxml=1.0.0，这样来来去去很麻烦，所以不如创建虚拟环境A装selenium2.48.0 和 lxml=1.0.0和虚拟环境B装selenium==2.50.0 和 lxml =1.2.0，做项目A就用虚拟环境A，项目B用虚拟环境B，互不干扰就方便多了。

###	新建文件模板配置

```python
${PROJECT_NAME} - 当前项目的名称。

${NAME} - 在文件创建过程中在“新建文件”对话框中指定的新文件的名称。

${USER} - 当前用户的登录名。

${DATE} - 当前的系统日期。

${TIME} - 当前系统时间。

${YEAR} - 今年。

${MONTH} - 当月。

${DAY} - 当月的当天。

${HOUR} - 目前的小时。

${MINUTE} - 当前分钟。

${PRODUCT_NAME} - 将在其中创建文件的IDE的名称。

${MONTH_NAME_SHORT} - 月份名称的前3个字母。 示例：1月，2月等

${MONTH_NAME_FULL} - 一个月的全名。 示例：1月，2月等
```





##	模块（Module）

为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，在Python中，一个`.py`文件就称之为一个**模块（Module）**。

**相同**名字的函数和变量完全**可以**分别存在不同的模块中，但是也要注意，**尽量不要与内置函数名字冲突**。

###	模块导入

用 **import** 或者 **from...import** 来导入相应的模块。

1. 将整个模块(somemodule)导入，格式为： 

   **import somemodule**

2. 从某个模块中导入某个函数,格式为： 

   **from somemodule import somefunction**

3. 从某个模块中导入多个函数,格式为：

   **from somemodule import firstfunc, secondfunc, thirdfunc**

4. 将某个模块中的全部函数导入，格式为：

   **from somemodule import \***



##	包（Package）

为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为**包（Package）**。

假设我们的`abc`和`xyz`这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如`mycompany`，按照如下目录存放：

mycompany
├─ \__init__.py
├─ abc.py
└─ xyz.py

引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，`abc.py`模块的名字就变成了`mycompany.abc`，类似的，`xyz.py`的模块名变成了`mycompany.xyz`。（类似于C语言中的结构体，abc.py、xyz.py变成了结构体中的成员）



##	输入输出

1. 使用input()输入

   xx=input("提示文字")

   1. 在Python 3.x中该函数输入均视为字符串读取
   2. 在Python 2.x中该函数可直接输入数值，输入字符串需要将字符串用双引号括起来

2. 使用print()输出

   1. 输出类型：

      1. 变量(字符串需要用引号括起来)
      2. 含有运算符的表达式

   2. 默认输出是换行的，如果要实现不换行可在变量末尾加上 **,end=" "**

      print( x, end=" "，sep=" " )

   3. 输出多个变量可用"**,**"分隔
   
   4. 格式化输出形同C语言
   
      ```python
      print("%_"%(_))
      ```
   
      ![](E:\Study Notes\Pictures\Python格式化操作符辅助指令.png)
   
      ![Python格式化输入输出](E:\Study Notes\Pictures\Python格式化输入输出.png)

##	文件操作

1. 输出

   输出到文件中(与C相似,但需要用==/替换\\==)

   1. 打开文件

      `open('文件绝对路径'，'a+')`

   2. print('xxx',file=指向文件的文件指针)

   3. 关闭文件

      `文件指针.close()`



##	基础语法

###	保留字

保留字是Python中一些已经被赋予特殊意义的单词，不能把这些保留字作为变量、函数、类、模块和其他对象的名称来使用

Python中所有的保留字是区分字母大小写的

查看保留字可使用keyword模块

```python
import keyword
keyword.kwlist
```

![](E:\Study Notes\Pictures\Python保留字.png)

错误代码：“invalid syntax”

###	标识符

标识符可以简单地理解成一个名字，主要用来标识变量、函数、类、模块和其他对象的名称

1. 标识符由字母、数字以及下划线(_)组成，但不能以数字开头
2. 不能使用保留字
3. **区分大小写**
4. 以下划线开头的标识符是有特殊意义的
   1. 以单下划线"_"开头的模块变量或者函数是受保护的，在使用from xx import *语句从模块导入时这些变量或者函数不能被导入
   2. 以双下划线开头的代表类的私有成员
   3. 以双下划线开头和结尾的代表 Python 里特殊方法专用的标识，如 \__init__() 代表类的构造函数
5. 可以同一行显示多条语句，方法是用分号 **;**分开

###	运算符

1. 算数运算符

   ![image-20220220232641177](E:\Study Notes\Pictures\Python算数运算符.png)

   除数不能为0，取模时如果除数为负数则结果也为负值

   Python 3.x中整数相除计算结果为浮点数

2. 赋值运算符

   ![image-20220220233852935](E:\Study Notes\Pictures\Python赋值运算符.png)

3. 比较(关系)运算符

   ![image-20220220234034532](E:\Study Notes\Pictures\比较运算符.png)

   判断一个变量是否介于两个值之间可采用"值1<变量<值2"的形式

4. 逻辑运算符

   | 运算符 |  含义  |    用法     | 结合方向 |
   | :----: | :----: | :---------: | :------: |
   |  and   | 逻辑与 | op1 and op2 | 从左到右 |
   |   or   | 逻辑或 | op1 or op2  | 从左到右 |
   |  not   | 逻辑非 |   not op    | 从右到左 |

5. 位运算符

   ![image-20220220235234232](E:\Study Notes\Pictures\Python位运算符.png)

   左端为高位端，右端为低位端

6. 成员运算符

   ![image-20220221000905312](E:\Study Notes\Pictures\Python成员运算符.png)

7. 身份运算符

   ![image-20220221001117806](E:\Study Notes\Pictures\Python身份运算符.png)

8. 运算符的优先级

   优先级高的运算先执行，同一优先级的操作从左到右进行，可使用()优先执行

   ![image-20220221001836009](E:\Study Notes\Pictures\Python运算符优先级.png)

###	注释

1. 单行注释用 **#** 
2. 多行注释可以用一对 **'''** 和 **"""**
2. 中文编码声明注释 **# -\*- coding:编码 -\*-**

###	代码组

缩进相同的一组语句构成一个代码块，称之代码组

首行以关键字开始，以冒号( : )结束

首行及后面的代码组称为一个子句(clause)

###	 命令行参数

1. Python 提供了 **getopt** 模块来获取命令行参数

   ```python
   getopt.getopt(args, options[, long_options])
   
   args: 要解析的命令行参数列表。
   options: 以字符串的格式定义，options 后的冒号 : 表示该选项必须有附加的参数，不带冒号表示该选项不附加参数
   long_options: 以列表的格式定义，long_options 后的等号 = 表示如果设置该选项，必须有附加的参数，否则就不附加参数
   ```

2. Python 中也可以所用 **sys** 的 **sys.argv** 来获取命令行参数

   ```python
   sys.argv 是命令行参数列表
   len(sys.argv) 计算命令行参数个数
   sys.argv[0] 表示脚本名
   
   eg：
   import sys
   print ('参数个数为:', len(sys.argv), '个参数。')
   print ('参数列表:', str(sys.argv))
   print ('脚本名:', str(sys.argv[0]))
   ```

   



##	常用函数

1. type()用于获取变量数据类型
2. id()用于获取变量在内存中的地址
3. range(start, end, step)用于生成一系列连续的整数，返回的是一个**可迭代对象**（类型是对象），而不是列表类型， 所以打印的时候不会打印列表
   1. start 指定计数的起始值，可以省略，如果省略则从0开始
   2. end  指定计数的结束值(**但不包括该值**，即**左闭右开**，反向输出的时候同理)，不能省略，函数必须含有该值
   3. step 指定步长，即两个数之间的间隔，可以省略
4. reversed()用于反向序列中的元素
10. enumerate()用于将序列组合成一个索引序列，多用在for循环中




##	标准数据类型

- **不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；
- **可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。

###	变量

可理解为值在内存中的"标签"

在Python中不需要先声明变量名及其类型，直接赋值即可创建各种类型的变量，且赋值以后该变量才会被创建

在 Python 中，变量就是变量，它没有类型，我们所说的"类型"是变量所指的内存中对象的类型

变量的类型可以随时变化

变量名需慎用小写字母l和大写字母O

应选择有意义的单词作为变量名

使用内置函数type()可以返回变量类型



### 多个变量赋值

1. a = b = c = 1

   这种赋值方法使变量都指向同一个内存地址

2. a, b, c = 1, 2, "runoob"

###	Number （数字）

数字类型是不可改变的，如果修改数字类型变量的值，那么会先把该值存在内存中，然后修改变量让其指向新的内存地址

1. **int** (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long

   1. 十进制整数不能以0作为开头
   2. 八进制整数以0o/0O开头
   3. 十六进制整数以0x/0X开头

2. **bool** (布尔), 表示真值或假值，在Python中标识符True和False被解释为布尔值

   布尔值可以转化为数值，True表示1，False表示0

   布尔类型可以进行数值运算，但不建议使用

   所有的对象都可以进行真值测试，只有以下几种情况得到的值为假：

   1. False或None
   2. 数值中的0
   3. 空序列
   4. 自定义对象的实例，该对象的\__bool_\_方法返回False或者\__len__方法返回0

3. **float** (浮点数), 如 1.23、3E-2

4. **complex** (复数), 如 1 + 2j、 1.1 + 2.2j

   由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型

内置的 type() 函数可以用来查询变量所指的对象类型

###	Sequence（序列）

一块用于存放多个值的连续内存空间，每一个值(称为元素)都分配一个数字，称为**索引**或位置，类似C语言中的数组下标

![image-20220216223523384](E:\Study Notes\Pictures\字符串索引和截取.png)

1. 索引(indexing)：从左往右以 **0** 开始，从右往左以 **-1** 开始

2. 切片(sliceing)：访问一定范围内的元素。

   第一个元素和最后一个元素为**：**，从左往右以 **1** 开始，从右往左以 **-1** 开始，**sequencename[start:stop"step]**，如果第三个参数为负数表示逆向读取，复制整个序列可以将头下标和尾下标省略只保留"**:**"(xx[:])

   1. print(str[2:5])       =>cde       输出从==第三个==开始到==第五个==的字符
   2. print(str[2:])         =>cdef      输出从==第三个==开始后的==所有==字符
   3. print(str[1:5:2])    =>bd         输出从==第二个==开始到==第五个==且==每隔一个==的字符（步长为2,即数组下标+2）

3. 序列相加(adding)：Python中支持两种**相同类型**的序列相加操作，即使用加(+)运算符实现

4. 乘法(multiplying)：Python中使用数字n乘以一个序列会生成原序列被重复n次的新序列

   可初始化指定长度的列表：emptylist=[None]*x

####	String（字符串）

1. 有两种常用的字符串类型，分别为str和bytes，str表示Unicode字符(ASCII码或其他)，bytes表示二进制数据(包括编码的文本)，这两种类型的字符串不能拼接在一起使用，通常情况下，str在内存中以Unicode表示，一个字符对应若干个字节，但如果在网络上传输或存储到磁盘上则需要把str转换为bytes类型

1. 单引号 **'** 和双引号 **"** 使用完全相同

2. 使用三引号(**'''** 或 **"""**)可以指定一个多行字符串

3. 需要表示复杂的字符串时，还可以嵌套使用引号

4. 转义符 **\\**

   ![image-20220220230311929](E:\Study Notes\Pictures\Python转义字符.png)

5. 反斜杠可以用来转义，使用 **r或R** (指 raw)可以让反斜杠不发生转义

    如 **r"this is a line with \n"** 则 **\n** 会显示，并不是换行

8. 字符串==不能改变==(相当于C语言中的字符串常量)

7. Python 没有单独的字符类型，一个字符就是长度为 1 的字符串

8. 拼接字符串

    使用"+"运算符可以完成对多个字符串的拼接

    ```python
    print("abc"+"123")
    ```

    不允许与其他类型的数据拼接，可用str()函数转换为字符串类型后进行拼接

9. 使用len()函数计算字符串长度

    通过len()函数计算字符串长度时所有字符都按一个字符算

    获取字符串实际所占字节数可使用encode()方法进行编码后再进行获取

    ```python
    str1="LeK"
    # UTF-8编码
    length=len(str1.encode())
    
    # GBK编码
    length=len(str1.encode("GBK"))
    ```

10. 分割字符串

    将字符串分割成列表

    字符串的split()方法可以实现字符串的分割，将字符串按照指定的分隔符切分成字符串列表，列表元素中不包括分隔符

    ```python
    str.split(sep,maxsplit)
    ```

    sep：用于指定分隔符，可以包含多个字符，默认为None，即所有空字符(包括空格、换行"\n"、制表符"\t"等)

    maxsplit：可选参数，用于指定分割的次数，如果不指定或指定为-1则分割次数没有限制，否则返回结果列表的元素个数，个数最多为maxsplit+1

    返回值：分割后的字符串列表

    如果不指定sep参数，就不能指定maxsplit参数

    如果采用默认空白符进行分割，则连续的空白符作为一个分隔符进行分割，如果指定一个分隔符切该分隔符连续出现时，就会每个分隔一次，没有得到内容的将产生一个空元素

    ```python
    str="111 >>> 222"
    print(str.split(">"))
    
    ["111 ","",""," 222"]
    ```

11. 合并字符串

     将字符串列表合并为字符串

     使用字符串对象的join()方法将多个字符串采用固定的分隔符连接在一起

     ```python
     strnew=string.join(iterable)
     
     eg:
         strnew="*".join(listname)
     ```

     string：字符串类型，用于指定合并时的分隔符

     iterable：可迭代对象，该迭代对象中的所有元素(字符串表示)将被合并成一个新的字符串

     使用join()方法时，第一个元素前不加分隔符

12. 检索字符串

     1. count()方法

         检索指定字符串在另一个字符串中出现的次数，如果检索的字符串不存在则返回0，否则返回出现的次数

         ```python
         str.count(sub, start= 0,end=len(string))
         ```

         str：原字符串

         sub：要检索的子字符串

         start：可选参数，表示检索范围的起始位置的索引，如果不指定则从头开始检索

         end：可选参数，表示检索范围的结束位置的索引，如果不指定则一直检索到结尾

     2. find()方法

         检索是否包含指定子字符串，如果不存在则返回-1，否则返回首次出现该字符串时的索引

         ```python
         str.find(sub, start= 0,end=len(string))
         ```

         如果只是想判断字符串是否存在可以使用成员运算符"in"

         rfind()方法作用与find()类似，只是从字符串右端开始查找

     3. index()方法

         与find()方法类似，也是用于检索是否包含指定的子字符串，但该方法当指定的字符串不存在时会抛出异常

         ```python
         str.index(sub, start= 0,end=len(string))
         ```

         rindex()方法作用与index()类似，只是从字符串右端开始查找

     4. startswith()方法

         用于检索字符串是否以指定子字符串开头，如果是则返回True，否则返回False

         ```python
         str.startswith(prefix,start=0,end=len(string))
         ```

     5. endswith()方法

         用于检索字符串是否以指定子字符串结尾，如果是则返回True，否则返回False

         ```python
         str.endswith(prefix,start=0,end=len(string))
         ```

13. 字母的大小写转换

     1. lower()方法

         将字符串中的大写字母转换为小写字母

     2. upper()方法

         将字符串中的小写字母转换为大写字母

14. 去除字符串中的空格和特殊字符

     1. lstrip()方法

         用于去掉字符串左侧的空格和特殊字符

         ```python
         str.lstrip([chars])
         ```

         chars：可选参数，用于指定要去除的字符，可以指定多个

     2. rstrip()方法

         用于去掉字符串右侧的空格和特殊字符

         ```python
         str.rstrip([chars])
         ```

         chars：可选参数，用于指定要去除的字符，可以指定多个

     3. strip()方法

         用于去掉字符串左右两侧的空格和特殊字符,即在 string 上执行 lstrip()和 rstrip()

         ```python
         str.strip([chars])
         ```

         chars：可选参数，用于指定要去除的字符，可以指定多个

15. 格式化字符串

     格式化字符串是指先制定一个模板，在这个模板中预留几个空位，然后再根据需要填上相应的内容。这些空位需要通过指定的占位符标记，而这些符号并不会显示出来

     1. 使用"%"操作符

         ```python
         "%[+][-][0][m][.n]格式化字符"%exp
         ```

         +：可选参数，用于指定右对齐，正数前方加正号，负数前方加负号

         -：可选参数，用于指定左对齐，正数前方无符号，负数前方加负号

         0：可选参数，表示右对齐，正数前方无符号，负数前方加负号，用0填充空白处

         m：可选参数，表示占有宽度

         .n：可选参数，表示小数点后保留的位数

         exp：要转换的项，如果指定的项有多个则需要通过元组的形式进行指定

         格式化字符：用于指定类型

         ![](E:\Study Notes\Pictures\Python格式化操作符辅助指令.png)

         ![Python格式化输入输出](E:\Study Notes\Pictures\Python格式化输入输出.png)

     2. format()方法

         ```python
         str.format(args)
         ```

         format：用于指定字符串的显示模板

         args：用于指定要转换的项，如果有多项要用逗号进行分隔

         创建模板时要用"{}" ":"指定占位符

         ```python
         {[index][: [[fill]align] [sign] [#] [width] [.precision] [type] ]}
         ```

         index：可选参数，用于指定要设置格式的对象在参数列表中的索引位置，索引值从0开始，默认根据值的先后顺序自动分配

         fill：可选参数，用于指定空白处填充的字符

         align：可选参数，用于指定对齐方式("<"表示内容左对齐，">"表示内容右对齐，"="表示内容右对齐且符号放在填充内容的最左侧且只对数字类型有效，"^"表示内容居中)，需要配合width一起使用

         sign：可选参数，"+"表示正数加正号负数加负号，"-"表示正数不变负数加负号，" "表示正数加空格负数加负号

         #：可选参数，对于二进制、八进制、十六进制数，会显示0b/0o/0x前缀

         width：可选参数，用于指定所占宽度

         .precision：可选参数，用于指定保留的小数位数

         type：可选参数，用于指定类型

         当一个模板中出现多个占位符时，指定索引位置的规范需统一，即全部采用手动指定或全部采用自动指定
    
17. 编码转换

      1. 使用encode()方法编码

          用于将字符串转换为bytes，也称为"编码"

          ```python
          str.encode([encoding="xxx"],[errors="yyy"])
          ```

          encoding=" "：可选参数，用于指定进行转码时采用的字符编码，默认为UTF-8，当只有这一个参数时可以省略前面的"coding="直接写编码

          errors=" "：可选参数，用于指定错误处理方式，可选择值有"strict"(遇到非法字符就抛出异常)、"ignore"(忽略非法字符)、"replace"(用"?"替换非法字符)				   或"xmlcharrefreplace"(使用XML的字符引用)等，默认值为strict

          使用encode()方法不会修改原字符串

      2. 使用decode()方法解码

          用于将bytes转换为字符串，也称为"解码"

          ```python
          bytes.decode([encoding="xxx"],[errors="yyy"])
          ```

          在设置解码采用的字符编码时应与编码时采用的字符编码一致

          使用decode()方法不会修改原字符串
          
          
          
          ##	




####	List（列表）

1. 列表中元素的类型可以不相同(但不建议这么做)，它支持数字、字符串、嵌套列表等任何类型，元素之间没有任何关系

2. 列表是写在方括号 **[ ]** 之间、用逗号分隔开的元素列表

3. 和字符串一样，列表同样可以被索引和切片，列表被截取后返回一个包含所需元素的新列表

4. ==与字符串不一样的是，列表中的元素是可以改变的==

5. ==与C语言数组不一样的是，列表中的元素可以赋空值的==（a[x:y] = []）

6. 创建：

   1. 使用赋值运算符直接创建列表

   2. 创建空列表（a[x:y] = [ ]    listname=[ ])

   3. 创建数值列表

      list(data)用于将序列、对象等转换为列表

7. 删除：del listname

   并不常用，Python自带的垃圾回收机制会自动销毁不用的列表
   
8. 遍历

   1. 直接使用for循环实现

      ```python
      for item in listname
      #	输出item
      ```

      item保存获取到的元素值

   2. for循环和enumerate()函数实现

      ```python
      for index,item in enumerate(listname)
      #	输出index和item
      ```

      index保存元素的索引，item保存获取到的元素值
   
9. 使用append()方法在列表末尾添加元素

   ```python
   listname.append(abj)
   ```

   使用insert()方法在列表指定位置添加元素

   ```python
   listname.insert(index, obj)
   ```

   使用extend()方法将一个列表中的所有元素添加到另一个列表末尾

   ```python
   listname.extend(seq)
   ```

10. 删除元素

    1. 根据索引删除
    


```python
del listname[index]
```

2. 根据元素值删除


```python
listname.remove(obj)
```

11. 获取指定元素出现的次数

    ```python
    listname.count(obj)
    ```

    返回值为元素在列表中出现的次数

12. 获取指定元素首次出现的下标

    ```
    listname.index(obj)
    ```

    返回值为首次出现时的索引值

13. 统计数值列表的元素和

    ```python
    sum(iterable[],start)
    ```

    iterable为要统计的列表

    start即将统计结果加上start所指定的数，默认为0

14. 排序

    1. 使用列表对象的sort()方法

       ```python
       listname.sort(cmp[, key=None[, reverse=False]])
       ```

       **原列表中的元素顺序将发生改变**

       cmp：排序时进行比较的函数，可以指定一个函数或者lambda函数

       key:可选参数，表示指定从每个元素中提去一个用于比较的键(例如设置"key=str.lower"表示在排序时不区分字母大小写)，指定取待排序元素的哪一项进行排序

       reverse:可选参数，如果将其值指定为True，则表示降序排列；如果为False，则表示升序排列，默认为升序排列

    2. 使用Python内置的sorted()函数实现

       ```python
       sorted(iterable,cmp,key=None,reverse=False)
       ```

       **使用该函数排序后原列表的元素顺序不变**，返回一个排序后的新对象

15. 列表推导式

    1. 生成指定范围的数值列表

       ```python
       list=[expression for var in range]
       
       eg:
           list=[random.randint for i in range(10)]
       ```

       expression:表达式，用于计算新列表的元素

       var:循环变量

       range:采用range()函数生成的range对象

    2. 根据列表生成指定需求的列表

       ```python
       newlist=[expression for var in list]
       
       eg:
           newlist=[int(x*0.5) for x in oldlist]
       ```

       list:用于生成新列表的原列表

    3. 从列表中选择符合条件的元素组成新的列表

       ```python
       newlist=[expression for var in list if condition]
       
       eg:
           newlist=[x for x in oldlist if x>5000]
       ```

       condition:条件表达式，用于指定筛选条件

16. 二维列表的使用

    1. 使用嵌套的for循环创建

       ```python
       arr=[]
       for i in range(4):
           arr.append([])
           for j in range(5):
               arr[i].append(j)
       ```

    2. 使用列表推导式创建

       ```python
       arr=[[j for j in range(5)] for i in range(4)]
       ```

       



####	Tuple（元组）

1. `tuple`中存储的是元素所对应的==地址==

2. 元组（tuple）与列表类似，不同之处在于元组的元素==不能修改==。元组写在小括号 **()** 里，元素之间用逗号隔开

3. 字符串可看作一种特殊的元组

4. 元组也可以被索引和切片

5. 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list、变量

5. Python内部实现对元组做了大量优化，访问和处理速度比**列表**快

5. 元组可用作字典的键，而列表则永远都不能当做字典键使用

6. **构造包含 0 个或 1 个元素的元组比较特殊**

   ```python
   tup1 = ()    # 空元组
   tup2 = (20,) # 一个元素，需要在元素后添加逗号
   ```
   
   空元组可应用在为函数传递一个空值或返回空值时
   
9. 创建数值元组

   ```python
   tuple(data)
   ```

   data表示可转换为元组的数据，其类型是可迭代的数据

10. 删除元组

   ```python
   del tuplename
   ```

11. 修改元组元素

    元组是不可变序列，所以不能进行当个元素的修改，但可以对元组进去整体的重新赋值，也可以对元组进行连接组合

12. 生成器表达式

    生成器表达式生成的结果并不是一个元组或者列表，而是一个生成器对象，这一点是和列表推导式不同的

    若直接打印生成器推导式的创建结果，则会显示该对象的存储地址

    1. 使用tuple()函数将其转换为元组

    ```python
    eg:
    import random
    randomnumber=(random.randint(10,100) for i in range(10))
    randomnumber=tuple(randomnumber)
    ```

    2. 遍历

       只能从前往后正向访问每个元素，没有任何方法可以再次访问已访问过的元素，也不支持使用下标访问其中的元素。当所有元素访问结束以后，如果需要重新访问其中的元素，必须重新创建该生成器对象

       1. 使用\__next__()方法进行遍历

       ```python
       eg:
       number=(i for i in range(5))
       print(number.__next__())
       ```

       2. 使用for循环进行遍历

       ```
       eg:
       number=(i for i in range(4))
       for i in number:
       	print(i)
       ```

       

####	Dictionary（字典）

1. 字典是无序的对象集合,字典当中的元素是通过键来存取的，有时也称为关联数组或者散列表(hash)

2. 字典是一种**映射**类型，字典用 **{ }** 标识，它是一个无序的 **键(key) : 值(value)** 的集合
3. 键是惟一的，而值可以有多个，如果出现两次同样的键，则后一个值会被记住
4. 键只能使用不可变的数据类型充当
5. 通过键而不是通过索引来读取

```python
dict = {}
dict['one'] = "1 - 菜鸟教程"
dict[2]     = "2 - 菜鸟工具"

tinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}


print (dict['one'])       # 输出键为 'one' 的值
print (dict[2])           # 输出键为 2 的值
print (tinydict)          # 输出完整的字典
print (tinydict.keys())   # 输出所有键
print (tinydict.values()) # 输出所有值
```

6. 创建

   1. 创建空字典

      ```python
      1.	dictionary={}
      2.	dictionary=dict()
      ```

   2. 通过映射函数创建字典

      ```python
      dictionary=dict(zip(list1,list2))
      ```

      zip()函数用于将多个列表和元组对应位置的元素组合为元组，并返回包含这些内容的zip对象

      list1用于指定要生成字典的键

      list2用于指定要生成字典的值

      如果list1和list2长度不同，则与最短的列表长度相同

   3. 通过给定的**键-值对**创建字典

      ```python
      dictionary=dict(key1=value1,key2=value2,....)
      ```

   4. 使用dict对象的fromkeys()方法创建值为空的字典

      ```python
      dictionary=dict.fromkeys(list1)
      ```

      list1是作为字典的键的列表

   5. 删除字典的全部元素

      ```python
      dictionary.clear()
      ```

      除此之外还可以使用pop()方法删除并返回指定"键"的元素，使用popitem()方法返回最后插入键值对

   6. 通过键值对访问字典

      ```python
      dictionary[key]
      ```

   7. 使用get()方法获取指定键的值

      ```python
      dictionary.get(key,[default])
      ```

      key为指定的键

      default为可选项，用于指定当键不存在时，返回一个默认值，默认为None

   8. 使用items()方法遍历

      ```python
      for item in dictionary.items():
          print(item)
          
      for key,value in dictionary.items():
          print(key,value)
      ```

      返回值为可遍历的键值对的元组列表

      还可以使用keys() values()方法获取字典的键和值

   9. 添加元素

      ```python
      dictionary[key]=value
      ```

      如果新添加的元素的键与原有键重复，那么新的值会代替原来的值

   10. 字典推导式

       ```python
       import random
       dictionary={i:random.randint(10,100) for i in range(5)}
       
       dictionary={i:j for i,j in zip(list1,list2)}
       ```



####	Set（集合）

集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员，与数学中的集合概念类似，用于保存不重复元素，有可变集合(set)和不可变集合(frozenset)两种

1. 可以使用大括号 **{ }** 或者 **set()** 函数创建集合，注意：创建一个空集合必须用 **set()** 而不是 **{ }**，因为 **{ }** 是用来创建一个空字典

   ```python
   parame = {element1,element2,...}
   
   setname=set(iteration)
   ```

   iteration为可迭代对象，若该对象为字符串则返回的集合将包含全部不重复字符的集合

2. 使用add()方法添加元素

   ```python
   setname.add(element)
   ```

   element只能使用**字符串、数字及布尔类型的True/False**

3. 删除

   可以使用del命令删除整个集合，也可以使用pop()或者remove()方法删除一个元素，或者使用clear()方法清空集合

4. 基本功能是进行**成员关系测试**和**删除重复元素**

   1. ```python
      sites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}
      
      print(sites)   # 输出集合，重复的元素被自动去掉
      ```

   2. ```python
      # 成员测试
      if 'Runoob' in sites :
          print('Runoob 在集合中')
      else :
          print('Runoob 不在集合中')
      ```

5. 并集、交集、差集运算

   ```python
   a = set('abracadabra')
   b = set('alacazam')
   
   print(a)
   
   print(a - b)     # a 和 b 的差集
   
   print(a | b)     # a 和 b 的并集
   
   print(a & b)     # a 和 b 的交集
   
   print(a ^ b)     # a 和 b 中不同时存在的元素
   ```

   

##	数据类型转换

![image-20220220231948606](E:\Study Notes\Pictures\Python数据类型转换函数.png)

转换后原变量数据类型不变

##	选择结构

选择语句主要有3种形式，分别为if语句、if...else语句和if...elif...else语句

```python
if 表达式:
	语句块
elif 表达式:
    语句块
else 表达式:
    语句块
```

##	循环结构

分为计数循环(for)和条件循环(while)

1. **while**

   ```python
   while 条件表达式:
   	循环体
   ```

2. **for**

   ```python
   for 迭代变量 in 对象:
   	循环体
   ```

   迭代变量用于保存读取出的值；对象为要遍历或迭代的对象，该对象可以是任何有序的**序列**对象

   可遍历数字、序列、集合、字典等

3. **else**

   else 中的语句会在循环正常执行完（即不是通过 break 跳出而中断的）的情况下执行，可用于for和while

4. 结束循环

   1. **break**

      终止当前的循环代码组

   2. **continue**

      终止本次循环，进行下一次循环

5. **pass**

   不做任何事情，起占位作用



##	正则表达式

 在查找符合某些复杂规则的字符串时，正则表达式就是用于描述这些规则的工具，即记录文本规则的代码

1. 元字符

   | 字符         | 描述                                                         |
   | :----------- | :----------------------------------------------------------- |
   | \            | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\\' 匹配 "\\" 而 "\(" 则匹配 "("。 |
   | ^            | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。 |
   | $            | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。 |
   | *            | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
   | +            | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
   | ?            | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。 |
   | {n}          | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
   | {n,}         | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
   | {n,m}        | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |
   | ?            | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。 |
   | .            | 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"**(.\|\n)**"的模式。 |
   | (pattern)    | 改变限定符的作用范围、分组。匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。 |
   | (?:pattern)  | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (\|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\|ies) 就是一个比 'industry\|industries' 更简略的表达式。 |
   | (?=pattern)  | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95\|98\|NT\|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
   | (?!pattern)  | 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95\|98\|NT\|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
   | (?<=pattern) | 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"`(?<=95|98|NT|2000)Windows`"能匹配"`2000Windows`"中的"`Windows`"，但不能匹配"`3.1Windows`"中的"`Windows`"。 |
   | (?<!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反。例如"`(?<!95|98|NT|2000)Windows`"能匹配"`3.1Windows`"中的"`Windows`"，但不能匹配"`2000Windows`"中的"`Windows`"。 |
   | x\|y         | 匹配 x 或 y。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"。 |
   | [xyz]        | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。 |
   | [^xyz]       | 负值字符集合。匹配未包含的任意字符。例如， '\[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。 |
   | [a-z]        | 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 |
   | [^a-z]       | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'\[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 |
   | \b           | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
   | \B           | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
   | \cx          | 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
   | \d           | 匹配一个数字字符。等价于 [0-9]。                             |
   | \D           | 匹配一个非数字字符。等价于 \[^0-9]。                         |
   | \f           | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
   | \n           | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
   | \r           | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
   | \s           | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
   | \S           | 匹配任何非空白字符。等价于 \[^ \f\n\r\t\v]。                 |
   | \t           | 匹配一个制表符。等价于 \x09 和 \cI。                         |
   | \v           | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |
   | \w           | 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。               |
   | \W           | 匹配非字母、数字、下划线。等价于 '\[^A-Za-z0-9_]'。          |
   | \xn          | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。 |
   | \num         | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 |
   | \n           | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |
   | \nm          | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |
   | \nml         | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
   | \un          | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 |

   ```python
   eg:
   	[^a-zA-Z]
   ```

2. 正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

   相同优先级的从左到右进行运算，不同优先级的运算先高后低。

3. re模块

   1. 匹配字符串

      1. match()方法

         从字符串的开始处进行匹配，如果在起始位置匹配成功，则返回Match对象，否则返回None,第一个字母不符合条件时则不再进行匹配

         ```python
         re.match(pattern, string, [flags=0])
         
         eg:
             import re
             pattern=r"mr_\w+"
             string="MR_SHOP mr_shop"
             match=re.match(pattern,string,re.I)
         ```

         pattern：模式字符串，由要匹配的正则表达式转换而来

         string：要匹配的字符串

         flags：可选参数，表示标志位，用于控制匹配方式

         | 修饰符 | 描述                                                         |
         | :----- | :----------------------------------------------------------- |
         | re.I   | 使匹配对大小写不敏感                                         |
         | re.L   | 做本地化识别（locale-aware）匹配                             |
         | re.A   | 对于\w \W \b \B \d \D \s \S 值进行ASCII匹配                  |
         | re.M   | 多行匹配，影响 ^ 和 $                                        |
         | re.S   | 使 . 匹配包括换行在内的所有字符                              |
         | re.U   | 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.      |
         | re.X   | 忽略模式字符串中未转义的空格和注释，该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |

         match对象中包含了匹配值的位置和匹配数据:

         1. start()方法获取匹配值的起始位置
         2. end()方法获取匹配值的结束位置
         3. span()方法返回匹配位置的元组
         4. string()方法获取要匹配的字符串
         5. group()方法获取匹配的子字符串

      2. search()方法

         在整个字符串中搜索第一个匹配的值，如果在起始位置匹配成功，则返回Match对象，否则返回None

         ```python
         re.search(pattern, string, [flags=0])
         ```

      3. findall()方法

         在整个字符串中搜索所有符合正则表达式的字符串，并以列表的形式返回。如果匹配成功，则返回包含匹配结构的列表，否则返回空列表。

         ```python
         re.findall(pattern, string, [flags=0])
         ```

         如果在指定的模式字符串中包含分组，则返回与分组匹配的文本列表

   2. 使用sub()方法替换字符串

      ```python
      re,sub(pattern,repl,string,count,flags)
      ```

      pattern：模式字符串

      repl：替换的字符串

      string：要被查找替换的原始字符串

      count：可选参数，表示模式匹配后替换的最大次数，默认值为0，表示替换所有的匹配

      flags：可选参数，表示标志位，用于控制匹配方式

   3. 使用split()方法分割字符串

      根据正则表达式分割字符串，并以列表的形式返回

      ```python
      re.split(parttern,string,[maxsplit],[flags])
      ```

      maxsplit：可选参数，表示最大的拆分次数

      

##	函数

1. 创建函数

   ```python
   def functionname([parameterlist]):
       ['''comments''']
       [functionbody]
   ```

   parameterlist：可选参数，用于指定向函数中传递的参数

   comments：可选参数，表示为函数指定注释，如果指定了comments参数，那么在调用函数输入函数名称及左侧小括号时会显示该函数的帮助信息

   functionbody：可选参数，用于指定函数体，如果有返回值可以使用return语句返回

   即使函数没有参数也必须保留一对空的"()"

   functionbody和comments必须保持一定的缩进

2. 参数传递

   1. 当实参为**不可变对象**时进行值传递，改变形参的值不影响实参；当实参为**可变对象**时进行引用传递，形参和实参同时改变

   2. 位置参数也称为必备参数，必须按照正确的顺序传到函数中，即调用时的数量和位置必须与定义时一样
   
   3. 关键字参数时指使用形参的名字来确定输入的参数值，这种方式不需要与形参位置完全一致
   
   4. 在定义函数时可以直接指定形参的默认值，在没有实参传入时会直接使用该默认值而不会抛出异常，**指定默认的形参必须在所有参数的最后**(可使用\__defaults__方法查看函数的默认值参数的当前值)
   
   5. 最好使用None作为可变对象的默认值，再加上必要的检查代码
   
   6. 可变参数：
   
      可变参数也称不定长参数，即传入函数中的实参可以是任意多个
   
      1. *parameter
   
         这种形式表示接收任意多个实参并将其放到一个**元组**中
   
         如果想要使用一个已经存在的列表作为函数的可变参数，可以在列表的名称前加"*****"
   
      2. **parameter
   
         这种形式表示接收任意多个类似关键字参数一样显示赋值的实参，并将其放到一个**字典**中
   
         如果想使用一个已经存在的字典作为函数的可变参数，可以在字典的名称前加"******"
   
   7. 返回值：
   
      返回值可以是任意类型，无论return语句出现在函数的什么位置，只要得到执行，就会直接结束函数的运行
   
      ```python
      result=return[value]
      
      return value
      ```
   
      result：用于保存返回结果，如果返回一个值，该值可以为任意类型；如果返回多个值，那么保存的是一个元组
   
      value：可选参数，用于指定要返回的值，可以返回一个值也可以返回多个值
   
      当函数中没有return语句或省略了return语句的参数时将返回None，即返回空值
   
   8. 变量的作用域：
   
      1. 局部变量
   
         在函数内部定义并使用的变量，只在函数内部有效
   
      2. 全局变量
   
         在函数体外定义的变量
   
         在函数体内定义并且用global关键字修饰
   
      在局部变量和全局变量重名时，对函数体的变量进行赋值不影响函数体外的变量
   
   9. 匿名函数(lambda)
   
      匿名函数是指没有名字的函数，这样的函数只能使用一次。
   
      ```python
      result=lambda [arg1 [,arg2,...,argn] ]:expression
      
      eg:
          list.sort(key=lambda x:x[1] , reverse=False)
      ```
      
      result：用于调用lambda表达式，接收lambda的返回值
      
      [arg1 [,arg2,...,argn] ]：可选参数，用于指定向要传递的参数列表
      
      expression：必选参数，指定一个实现具体功能的表达式
      
      表达式只能有一个，即只能返回一个值，且不能出现其他非表达式语句(如for或while)
      
      首要用途是指定短小的回调函数



##	面向对象(Object  Oriented)

1. 概述

   1. 对象(Object)：一个抽象概念，表示任意存在的事物，通常将对象划分为静态部分和动态部分。静态部分被称为"属性"，任何对象都有自身属性；动态部分被称为"行为"，即对象执行的动作

   2. 类(Class)：类是封装对象的属性和行为的载体，即具有相同属性和行为的一类实体被称为类。在Python中，类是一种抽象概念，对象是类的实例

   3. 面向对象程序设计的特点：

      1. 封装

         面向对象编程的核心思想，将对象的属性和行为封装起来，其载体就是类，类通常会对用户隐藏其细节，这就是封装的思想。

         采用封装思想保证了类内部数据结构的完整性，用户仅能执行类允许公开的数据，避免了外部对内部数据的影响，提高程序的可维护性。

      2. 继承

         继承是实现重复利用的重要手段，子类通过继承复用了父类的属性和行为同时添加了子类特有的属性和行为

      3. 多态

         父类衍生出不同的子类，子类继承父类特征的同时也具有了自己的特征，且能够实现不同的效果

2. 类(Class)

   类是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。

   在使用类时，需要先定义类，再创建类的实例，通过类的实例就可以访问类中的属性和方法了

   1. 定义类

      ```python
      class Classname:
      	'''
      	类的帮助信息
      	'''
      	statement
      ```

      Classname：用于指定类名，一般使用大写字母开头，如果类名中包括两个单词，则第二个单词也用大写字母开头，即"驼峰式命名法"

      statement：类体，主要由类变量(或类成员)、方法和属性等定义语句组成，也可以使用pass语句代替

   2. 创建类的实例

      ```python
      ClassName(parameterlist)
      ```

      ClassName：必选参数，指定具体的类

      parameter：可选参数，当创建一个类时，如果没有创建\__init__()方法或该方法只有一个self参数，parameterlist可以省略

   3. 创建\__init__()方法

      该方法是一个特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法

      \__init__()方法必须包含一个self参数，且必须是第一个参数，self 在定义类的方法时是必须有的

      self参数是一个指向实例本身的引用，用于访问类中的属性和方法，在方法调用时会自动传递实际参数self

   4. 创建类的成员并访问

      类的成员主要由实例方法和数据成员组成

      1. 实例方法

         类中定义的函数，该函数是在类的实例上操作的函数

         ```python
         def functionname(self,paramentlist):
         	block
         ```

         functionname：指定方法名，一般使用小写字母开头

         self：必要参数，表示类的实例

         block：方法体，实现具体的功能

         ```python
         instanceName.functionname(parameterlist)
         ```

         instanceName：类的实例的名称

      2. 数据成员

         类中定义的变量，即属性，根据定义位置分为类属性和实例属性

         1. 类属性

            定义在类中且在方法外的属性，在类的所有实例中共享值，可以通过类名称或实例名访问

            可以动态地为类和对象添加修改属性，结果作用于所有实例

         2. 实例属性

            定义在类的方法中的属性，只作用于当前实例中，只能通过实例名访问

            实例属性可以通过实例名称更改 ，且更改后不影响该类的另一个实例中对应的实例属性的值

   5. 访问限制

      为了保证类内部某些属性和方法不被外部所访问，可以在属性或者方法名前面添加单下划线、双下划线、或首尾添加双下划线从而限制访问权限

      1. 首尾双下划线(\__foo__)：定义特殊方法，一般为系统定义名字
      2. 单下划线(_foo)：表示保护(protected)类型的成员，只允许类本身和子类进行访问，能通过实例名访问，但不能使用"from module import *"语句导入
      3. 双下划线(\__foo)：表示私有(private)类型的成员，只允许定义该方法的类本身进行访问，不能通过类的实例直接进行访问，但可以通过"instancename.\_ClassName__xxx"方式访问

3. 属性(Property)

   不同于类的数据成员，这种属性不返回存储的值，访问它时将计算它的值

   1. 创建

      通过@property(装饰器)将一个方法转换为属性，实现用于计算的属性

      将方法转换为属性之后可以直接通过方法名来访问方法而不需要再添加一对小括号"()"

      ```python
      @property
      def methodname(self):
          block
      ```

      block：方法体，通常以return语句结束用以返回计算结果

      通过@property转换后的属性不能重新赋值

   2. 添加安全保护机制

      为了创建一个课读取但不能修改的属性，可以使用@property实现只读属性

4. 继承

   继承表示这个类拥有它继承的类的所有公有成员和受保护成员，被继承的类称为父类或基类，新的类称为子类或派生类

   .号表示对.号前的对象调用其方法或访问其成员，而这个访问的过程，就是从继承搜索树的叶子节点，即子类开始寻找.号后面的函数或成员，如果能找到，就停止搜索；如果找不到，就往上的父类找。

   1. 基本语法

      ```python
      class ClassName(baseclasslist):
          statement
      ```

      baseclasslist：指定要继承的基类，可以有多个，如果不指定将使用所有Python对象的根类

   2. 方法重写

      当基类中的某个方法不完全适用于派生类时，就需要在派生类中重写基类的方法

   3. 在子类中调用父类的\__init__()方法

      在子类中定义\__init__()方法时，不会自动调用父类的初始化方法，因此调用父类的初始化方法需要进行必要的初始化

      ```python
      super.__init__()
      ```
