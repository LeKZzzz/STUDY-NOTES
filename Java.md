#	Java

---

#	JRE与JDK

JRE(Java Runtime Environment ) Java运行环境，用来运行JAVA程序，由JVM和Java类库共同构建。

JDK(Java Development Kit) Java开发工具包，包含JRE。因此只需要下载安装JDK即可。

JDK是Sun Microsystems针对Java开发员的产品，JSP(Java Server Pages，是由Sun Microsystems公司主导创建的一种动态网页技术标准)需要JDK的支持。

JDK 是整个Java的核心，包括了Java运行环境，Java工具和Java基础的类库。

JDK是Java语言的软件开发工具包(SDK)。

没有JDK的话，无法编译Java程序，如果想只运行Java程序，要确保已安装相应的JRE。

#	JavaEE JavaME JavaSE

SE(J2SE)，standardedition，标准版，是我们通常用的一个版本，从JDK5.0开始，改名为JavaSE，用来开发客户端的应用程序，应用程序可以独立运行或作为Applet在Web浏览器中运行。

EE(J2EE)，enterpriseedition，企业版，使用这种JDK开发J2EE应用程序，从JDK5.0开始，改名为JavaEE，用来开发服务端的应用程序，例如，Java Servlet、JSP、JSF。

ME(J2ME)，microedition，微型版，主要用于移动设备、嵌入式设备上的java应用程序，从JDK5.0开始，改名为JavaME，用来开发移动设备上运行的应用程序。

![](E:\Study Notes\Pictures\J2EE JavaME JavaSE)



#	JVM

JVM(Java Virtual Machine)，是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

JVM是一种用于计算设备的规范，它是一个虚构出来的机器，是通过在实际的计算机上仿真模拟各种功能实现的。
JVM包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域。
JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在JVM上运行的目标代码（字节码，即.class文件）,就可以在多种平台上不加修改地运行。
JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。

JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。
Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。

JVM执行程序的过程：

1. 加载.class文件
2. 管理并分配内存
3. 执行垃圾收集

JRE（java运行时环境）是由JVM构造的java程序的运行环，也是Java程序运行的环境，但是他同是一个操作系统的一个应用程序一个进程，因此他也有他自己的运行的生命周期，也有自己的代码和数据空间。
JVM在整个jdk中处于最底层，负责于操作系统的交互，用来屏蔽操作系统环境，提供一个完整的Java运行环境。

当一个Java程序执行时，JVM首先会用一个称为类加载器(class loader)的程序将类的字节码加载到内存中，如果程序还要用到其他类，类加载程序会在需要它们之前动态地加载它们。当加载该类后，JVM使用一个称为字节码验证器(bytecode verifier)的程序校验字节码的合法性，最后通过的字节码由运行时解释器(rutime interpreter)翻译和执行。



#	Java特性

Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。

Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等



#	.java文件和.class文件

.java文件是一个文本文件，就是我们用java语言写成的源程序。

.class文件是一种二进制文件，即字节码文件，.java文件是通过javac(编译器)编译生成的一个文件，可以由JVM装载(类装载)，然后由java(解释器)解释执行。

注意：

1. class文件名和类名保持一致
2. 公共类的类名要和.java文件名保持一致
3. 一个.java文件可以支持多个类，但是最多只能有一个公共类
4. java文件可以创建多个类，有几个类就能编译生成几个.class文件，如果.java文件中的类名出现大小写最后的结果是最后一类的内容





#	内存划分

1. 栈(Stack)：存放的是方法中的局部变量，局部变量一旦超出作用域会立刻从栈内存中消失，方法在栈中运行
2. 堆(Heap)：存放的是new出来的对象，堆内存中存放的数据都有一个16进制的地址值，堆内存中的数据都有默认值，整数类型默认为0，浮点类型默认为0.0，字符类型默认为\u0000，布尔类型默认为false，引用类型默认为null
3. 方法区(Method Area)：存储.class文件的相关信息，包含方法的信息
4. 本地方法栈(Native Method Stack)：与操作系统相关
5. 寄存器(pc Register)：与CPU相关

# IntelliJ IDEA

## 项目结构

> 项目(Project)
>
> > 模块(Module)
> >
> > > 包(Package)
> > >
> > > > 文件(File)



##	.iml文件

IDEA的配置文件

#	基础语法

1. Java 是**大小写敏感**的
2. **源文件名必须和类名相同**。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 **.java**。（如果文件名和类名不相同则会导致编译错误）
3. 所有的 Java 程序由 **public static void main(String[] args)** 方法开始执行。



## 标识符

1. 类名、变量名以及方法名都被称为标识符
2. 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始
3. 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合
4. **关键字不能用作标识符**
5. 标识符是大小写敏感的
6. 合法标识符举例：age、$salary、_value、__1_value
7. 非法标识符举例：123abc、-salary
8. **命名规范**
   1. 类名规范：首字母大写，后面的每个单词首字母大写(大驼峰式)
   1. 接口规范：同类名
   2. 变量名规范：首字母小写，后面的每个单词首字母大写(小驼峰式)
   3. 方法名规范：同变量名



##	修饰符

Java可以使用修饰符来修饰类中方法和属性，通常放在语句的最前端。主要有两类修饰符：

- 访问控制修饰符 : default, public , protected, private
- 非访问控制修饰符 : final, abstract, static, synchronized

1. 访问修饰符
   1. default : 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
   2. private : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。私有访问修饰符是最严格的访问级别，所以被声明为 **private** 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 **private**。
   3. public : 对所有类可见。使用对象：类、接口、变量、方法
   4. protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**
      1. **子类与基类在同一包中**：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；
      2. **子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。
2. 非访问修饰符
   1. static 修饰符，用来修饰类方法和类变量。
   2. final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
   3. abstract 修饰符，用来创建抽象类和抽象方法。
   4. synchronized 和 volatile 修饰符，主要用于线程的编程。



##	关键字

关键字是有特殊含义的、被保留的、完全小写的 、不能随意使用的字符，保留字不能用于常量、变量、和任何标识符的名称。

1. 访问控制

   | 关键字    | 说明     |
   | --------- | -------- |
   | private   | 私有的   |
   | protected | 受保护的 |
   | public    | 公共的   |
   | default   | 默认     |

2. 类、方法和变量修饰符

   | 关键字       | 说明                           |
   | ------------ | ------------------------------ |
   | abstract     | 声明抽象                       |
   | class        | 类                             |
   | extends      | 扩充,继承                      |
   | final        | 最终值,不可改变的              |
   | implements   | 实现（接口）                   |
   | interface    | 接口                           |
   | native       | 本地，原生方法（非 Java 实现） |
   | new          | 新,创建                        |
   | static       | 静态                           |
   | strictfp     | 严格,精准                      |
   | synchronized | 线程,同步                      |
   | transient    | 短暂                           |
   | volatile     | 易失                           |

3. 程序控制语句

   | 关键字     | 说明                       |
   | ---------- | -------------------------- |
   | break      | 跳出循环                   |
   | case       | 定义一个值以供 switch 选择 |
   | continue   | 继续                       |
   | default    | 默认                       |
   | do         | 运行                       |
   | else       | 否则                       |
   | for        | 循环                       |
   | if         | 如果                       |
   | instanceof | 实例                       |
   | return     | 返回                       |
   | switch     | 根据值选择执行             |
   | while      | 循环                       |

4. 错误处理

   | 关键字  | 说明                   |
   | ------- | ---------------------- |
   | assert  | 断言表达式是否为真     |
   | catch   | 捕捉异常               |
   | finally | 有没有异常都执行       |
   | throw   | 抛出一个异常对象       |
   | throws  | 声明一个异常可能被抛出 |
   | try     | 捕获异常               |

5. 包相关

   | 关键字  | 说明 |
   | ------- | ---- |
   | import  | 引入 |
   | package | 包   |

6. 基本类型

   | 关键字  | 说明       |
   | ------- | ---------- |
   | boolean | 布尔型     |
   | byte    | 字节型     |
   | char    | 字符型     |
   | double  | 双精度浮点 |
   | float   | 单精度浮点 |
   | int     | 整型       |
   | long    | 长整型     |
   | short   | 短整型     |

7. 变量引用

   | 关键字 | 说明      |
   | ------ | --------- |
   | super  | 父类,超类 |
   | this   | 本类      |
   | void   | 无返回值  |

8. 保留关键字

   | 关键字 | 说明                 |
   | ------ | -------------------- |
   | goto   | 是关键字，但不能使用 |
   | const  | 是关键字，但不能使用 |



##	运算符

> 结合性是指对某个运算符构成的表达式，计算时如果先取运算符左边的操作数，后取运算符，则该运算符是左结合的，若先取运算符右侧的操作数，后取运算符，则是右结合的。
>
> 所有的二元运算符（如+、<<等）都是左结合的，而赋值运算符（=、+=等）是右结合的。

1. 算数运算符

   | 操作符 | 描述                                                         | 例子               |
   | :----- | :----------------------------------------------------------- | :----------------- |
   | +      | 加法 - 相加运算符两侧的值，也可用于连接字符串对象            | A + B 等于 30      |
   | -      | 减法 - 左操作数减去右操作数                                  | A – B 等于 -10     |
   | *      | 乘法 - 相乘操作符两侧的值                                    | A * B等于200       |
   | /      | 除法 - 左操作数除以右操作数，如果两个操作数是整数，商为整数  | B / A等于2         |
   | ％     | 取余 - 左操作数除以右操作数的余数，当操作数含有负数时，余数的符号与被除数相同且余数的绝对值小于除数的绝对值 | B%A等于0           |
   | ++     | 自增: 操作数的值增加1                                        | B++ 或 ++B 等于 21 |
   | --     | 自减: 操作数的值减少1                                        | B-- 或 --B 等于 19 |

2. 关系运算符

   | 运算符 | 描述                                                         | 例子             |
   | :----- | :----------------------------------------------------------- | :--------------- |
   | ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。         | （A == B）为假。 |
   | !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。     | (A != B) 为真。  |
   | >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。   | （A> B）为假。   |
   | <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。   | （A <B）为真。   |
   | >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |
   | <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |

3. 位运算符

   | 操作符 | 描述                                                         | 例子                           |
   | :----- | :----------------------------------------------------------- | :----------------------------- |
   | ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
   | \|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
   | ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
   | 〜     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
   | <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
   | >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
   | >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

4. 逻辑运算符

   | 操作符 | 描述                                                         | 例子                |
   | :----- | :----------------------------------------------------------- | :------------------ |
   | &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。     | （A && B）为假。    |
   | \| \|  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \| \| B）为真。 |
   | ！     | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |

5. 赋值运算符

   | 操作符  | 描述                                                         | 例子                                     |
   | :------ | :----------------------------------------------------------- | :--------------------------------------- |
   | =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |
   | + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |
   | - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |
   | * =     | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |
   | / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |
   | （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |
   | << =    | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |
   | >> =    | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |
   | ＆=     | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |
   | ^ =     | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |
   | \| =    | 按位或赋值操作符                                             | C \| = 2等价于C = C \| 2                 |

6. 条件运算符：`condition?expression1:expression2`条件运算符也被称为三元运算符，condition为关系或逻辑表达式，其计算结果为布尔值，如果该值为true，则计算表达式expression1的值，并将计算结果作为条件表达式的结果；如果该值为false，则计算表达式expression2的值，并将计算结果作为条件表达式的结果

7. instanceof 运算符:该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）

   `( Object reference variable ) instanceof  (class/interface type)`

   如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真

8. 优先级

   | 类别     | 操作符                                     | 关联性   |
   | :------- | :----------------------------------------- | :------- |
   | 后缀     | () [] . (点操作符)                         | 左到右   |
   | 一元     | expr++ expr--                              | 从左到右 |
   | 一元     | ++expr --expr + - ～ ！                    | 从右到左 |
   | 乘性     | * /％                                      | 左到右   |
   | 加性     | + -                                        | 左到右   |
   | 移位     | >> >>>  <<                                 | 左到右   |
   | 关系     | > >= < <=                                  | 左到右   |
   | 相等     | == !=                                      | 左到右   |
   | 按位与   | ＆                                         | 左到右   |
   | 按位异或 | ^                                          | 左到右   |
   | 按位或   | \|                                         | 左到右   |
   | 逻辑与   | &&                                         | 左到右   |
   | 逻辑或   | \| \|                                      | 左到右   |
   | 条件     | ？：                                       | 从右到左 |
   | 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \| = | 从右到左 |
   | 逗号     | ，                                         | 左到右   |



##	注释

```java
//	这是单行注释

/*
这是多行注释
*/

/**
这是文档注释，这是Java特有的注释方式，主要用来生成类定义的api文档
*/
```





##	代码块

1. 代码块是由大括号围起来的一组语句，如类体、方法体、初始化块等
2. 格式
   1. 行末格式，即左大括号写在上一行的末尾，右大括号写在下一行
   2. 次行格式，即将左大括号单独写在下一行，右大括号与左大括号垂直对齐

#	数据类型

> Java 的两大数据类型:
>
> - 基本数据类型
> - 引用数据类型



##	常量

1. 常量在程序运行时是不能被修改的

2. 在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似

   ```java
   final double PI = 3.1415927;
   ```

3. 虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量

4. 分类

   1. 字符串常量：双引号引起来的部分
   2. 整形常量：直接写上的数字，没有小数点
   3. 浮点数常量：直接写上的数字，有小数点
   4. 字符常量：用单引号引起来的单个字符
   5. 布尔常量：true或false
   6. 空常量：null，代表无任何数据，也无法使用




##	变量

变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间

内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据

**在Java语言中，所有的变量在使用前必须声明**

> 1. 类变量：独立于方法之外的变量，用 static 修饰。
> 2. 实例变量：独立于方法之外的变量，不过没有 static 修饰。
> 3. 局部变量：类的方法中的变量。



###	变量的作用域

1. 变量的范围是程序中该变量可以被引用的部分。
2. 方法内定义的变量被称为局部变量。
3. 局部变量的作用范围从声明开始，直到包含它的块结束。
4. 局部变量必须声明才可以使用。
5. 方法的参数范围涵盖整个方法。参数实际上是一个局部变量。
6. for循环的初始化部分声明的变量，其作用范围在整个循环，但循环体内声明的变量其适用范围是从它声明到循环体结束。
7. 可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量



###	局部变量

1. 局部变量**声明在方法、构造方法或者语句块中**
2. 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁
3. 访问修饰符不能用于局部变量
4. 局部变量只在声明它的方法、构造方法或者语句块中可见
5. 局部变量是在栈上分配的
6. 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用



###	实例变量(成员变量)

1. 实例变量声明**在一个类中，但在方法、构造方法和语句块之外**
2. 当一个对象被实例化之后，每个实例变量的值就跟着确定
3. 实例变量在对象创建的时候创建，在对象被销毁的时候销毁
4. 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息
5. 实例变量可以声明在使用前或者使用后
6. 访问修饰符可以修饰实例变量
7. 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见
8. 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定
9. 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName



###	类变量(静态变量)

1. 类变量也称为静态变量，**在类中以 static 关键字声明，但必须在方法之外**
2. 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝，所有实例共享同一块内存空间
3. 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变
4. 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量
5. 静态变量在第一次被访问时创建，在程序结束时销毁
6. 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型
7. 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化
8. 静态变量可以通过：*ClassName.VariableName*的方式访问
9. 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致



##	字面值(literals)

1. 字面值是某种类型值的表示形式
2. 字面值有三种类型
   1. 基本类型的字面值：基本类型的字面值有4种类型：整数型、浮点型、布尔型、字符型。如123、-789为int型字面值，3.456、2e3为double型字面值，true、false为布尔型字面值，‘g’、‘我’为字符字面值
   2. 字符串字面值：用双引号定界的字符序列，如“Hello”是一个字符串字面值 
   3. null字面值
3. Ø从Java 7开始，在数值型字面值中可以使用下划线（_）将一些数字进行分组，这可以增强代码的可读性



##	基本数据类型

> Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型
>
> ```java
> 基本类型：byte 二进制位数：8
> 包装类：java.lang.Byte
> 最小值：Byte.MIN_VALUE=-128
> 最大值：Byte.MAX_VALUE=127
> 
> 基本类型：short 二进制位数：16
> 包装类：java.lang.Short
> 最小值：Short.MIN_VALUE=-32768
> 最大值：Short.MAX_VALUE=32767
> 
> 基本类型：int 二进制位数：32
> 包装类：java.lang.Integer
> 最小值：Integer.MIN_VALUE=-2147483648
> 最大值：Integer.MAX_VALUE=2147483647
> 
> 基本类型：long 二进制位数：64
> 包装类：java.lang.Long
> 最小值：Long.MIN_VALUE=-9223372036854775808
> 最大值：Long.MAX_VALUE=9223372036854775807
> 
> 基本类型：float 二进制位数：32
> 包装类：java.lang.Float
> 最小值：Float.MIN_VALUE=1.4E-45
> 最大值：Float.MAX_VALUE=3.4028235E38
> 
> 基本类型：double 二进制位数：64
> 包装类：java.lang.Double
> 最小值：Double.MIN_VALUE=4.9E-324
> 最大值：Double.MAX_VALUE=1.7976931348623157E308
> 
> 基本类型：char 二进制位数：16
> 包装类：java.lang.Character
> 最小值：Character.MIN_VALUE=0
> 最大值：Character.MAX_VALUE=65535
> ```

1. Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的"E+数字"表示E之前的数字要乘以10的多少次方
2. 当使用字面量的时候，前缀 **0** 表示 8 进制，前缀 **0x** 代表 16 进制，前缀0b或0B代表二进制
3. 数据范围与字节数不一定相关
4. 浮点数特殊值：
   - Infinity，-Infinity
    - NaN（Not A Number, 0.0/0.0）
5. 浮点数一般不能用 == 比较
6. 需要精确而无舍入误差的数字计算，可以使用java.math.BigDecimal类



###	byte

1. byte 数据类型是8位、有符号的，以二进制补码表示的整数
2. 最小值是 **-128（-2^7）**，最大值是 **127（2^7-1）**
3. 默认值是 **0**
4. byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一



###	**short**

1. short 数据类型是 16 位、有符号的以二进制补码表示的整数
2. 最小值是 **-32768（-2^15）**，最大值是 **32767（2^15 - 1）**
3. Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一
4. 默认值是 **0**



###	**int**

1. int 数据类型是32位、有符号的以二进制补码表示的整数
2. 最小值是 **-2,147,483,648（-2^31）**，最大值是 **2,147,483,647（2^31 - 1）**
3. 一般地整型变量默认为 int 类型
4. 默认值是 **0** 



###	**long**

1. long 数据类型是 64 位、有符号的以二进制补码表示的整数
2. 最小值是 **-9,223,372,036,854,775,808（-2^63）**，最大值是 **9,223,372,036,854,775,807（2^63 -1）**；
3. 这种类型主要使用在需要比较大整数的系统上
4. 默认值是 **0L**
5. 例子： **long a = 100000L**，**long b = -200000L**。
   "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写



###	**float**

1. float 数据类型是单精度、32位、符合IEEE 754标准的浮点数
2. float 在储存大型浮点数组的时候可节省内存空间
3. 默认值是 **0.0f**
4. 浮点数不能用来表示精确的值，如货币
5. 例子：float f1 = 234.5f



###	**double**

1. double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数

2. 浮点数的默认类型为 double 类型

3. double类型同样不能表示精确的值，如货币

4. 默认值是 **0.0d**

5. 例子：

   ```java
   double   d1  = 7D 
   double   d2  = 7.
   double   d3  =  8.0
   double   d4  =  8.D
   double   d5  =  12.9867
   ```



###	 **boolean**

1. boolean数据类型表示一位的信息
2. 只有两个取值：true 和 false
3. 这种类型只作为一种标志来记录 true/false 情况
4. 默认值是 **false**
4. boolean不能与数值数据相互转换，即不对应1/0



###	**char**

1. char 类型是一个单一的 16 位 Unicode 字符，Unicode字符集使用两个字节（16位）为字符编码，可表示65 536个字符。

2. 最小值是 **\u0000**（十进制等效值为 0），最大值是 **\uffff**（即为 65535）

3. char 数据类型可以储存任何字符

4. char允许输入单个汉字

4. 字面值用**单引号**将字符括起来，大多数可见的字符都可用这种方式表示，如'a'、'@'、'我'等

4. 有些特殊字符用转义序列来表示。用反斜杠（\）表示转义

   | 转义序列 | 描述                     |
   | :------- | :----------------------- |
   | \t       | 在文中该处插入一个tab键  |
   | \b       | 在文中该处插入一个后退键 |
   | \n       | 在文中该处换行           |
   | \r       | 在文中该处插入回车       |
   | \f       | 在文中该处插入换页符     |
   | \'       | 在文中该处插入单引号     |
   | \"       | 在文中该处插入双引号     |
   | \\       | 在文中该处插入反斜杠     |





##	引用数据类型

1. 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。
2. 类、字符串、对象、数组、接口、lambda、枚举类型、注解类型都是引用数据类型。
3. 所有引用类型的默认值都是null。
4. 一个引用变量可以用来引用任何与之兼容的类型。
5. 所有的引用类型变量都可以赋一个null值，代表元素为空



###	数组

1. Java 语言中提供的数组是只能存储固定大小的同类型元素
2. 数组的长度在程序运行期间不可改变
2. 直接打印数组名称得到的是数组对应的内存地址的哈希值
2. 使用动态初始化数组时，数组中的元素会自动拥有一个默认值，整数类型默认0，浮点类型默认为0.0，字符类型默认为\u0000，布尔类型默认为false，引用类型默认为null
2. 数组地址可以直接赋值给新的数组变量，新的数组变量获得其在堆内存中的数组首地址，该方法没有新开辟数组空间而是在操作同一个数组
2. 数组作为方法的参数和返回值时传递的是数组在堆内存中的地址值



####	声明数组

```java
dataType[] arrayRefVar;   // 首选的方法
 
 
dataType arrayRefVar[];  // 效果相同，但不是首选方法
```

> datatype：数组中保存的数据类型
>
> []：声明为数组
>
> arrayRefVar：数组名

1. 必须声明数组变量，才能在程序中使用数组
2. `dataType arrayRefVar[]` 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言



####	创建数组

1. ```java
   arrayRefVar = new dataType[arraySize];
   ```

   上面的语法语句做了两件事：

   1. 使用 dataType[arraySize] 创建了一个数组。
   2. 把新创建的数组的引用赋值给变量 arrayRefVar。

2. 数组变量的声明，和创建数组可以用一条语句完成

   ```java
   dataType[] arrayRefVar = new dataType[arraySize];
   ```

3. 可以在创建数组的同时为数组中的元素赋值

   ```java
   dataType[] arrayRefVar = new dataType[] {value0, value1, ..., valuek};
   dataType[] arrayRefVar = {value0, value1, ..., valuek};//省略格式初始化时不可单独使用
   ```

4. 初始化

   1. 动态初始化：指定长度，java中数组的长度可以用普通变量而不必须是常量
   2. 静态初始化：指定内容



####	内存划分

![](E:\Study Notes\Pictures\Java数组内存划分.png)

####	数组方法

1. `array.length`：返回一个int数字，代表数组长度





###	字符串






##	类型转换

###	自动类型转换

自动类型转换也称加宽转换，Ø它是指将具有较少位数的数据类型转换为具有较多位数的数据类型

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

```java
低  ------------------------------------>  高

byte,short,char —> int —> long —> float —> double 
```

- 不能对boolean类型进行类型转换
- 不能把对象类型转换成不相关类的对象
- **在把容量大的类型转换为容量小的类型时必须使用强制类型转换**
- 转换过程中可能导致溢出或损失精度
- 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入
- **必须满足转换前的数据类型的位数要低于转换后的数据类型**



###	强制类型转换

```java
(type) value
```

1. 数据类型必须是兼容的

2. 隐含强制类型转换：

   -  整数的默认类型是 int
   - 小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f
   - byte/short/char类型在运算时，都会首先被提升为int类型再进行运算
   - 对byte/short/char类型赋值时，如果右侧赋值的数据未超过这三种类型的最大范围，javac编译器会自动强制转换为byte/short/char类型

# 源文件声明规则

当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则：

1. 一个源文件中只能有一个 public 类
2. 一个源文件可以有多个非 public 类
3. 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。
4. 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。
5. 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。
7. import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。





# 流程

##	选择结构

1. ```java
   if(布尔表达式)
   {
      //单分支if语句
      //如果布尔表达式为true将执行的语句
   }
   ```
   
2. ```java
   if(布尔表达式){
      //双分支if-else语句
      //如果布尔表达式的值为true
   }else{
      //如果布尔表达式的值为false
   }
   ```
   
3. ```java
   if(布尔表达式 1){
      //如果布尔表达式 1的值为true执行代码
   }else if(布尔表达式 2){
      //如果布尔表达式 2的值为true执行代码
   }else if(布尔表达式 3){
      //如果布尔表达式 3的值为true执行代码
   }else {
      //如果以上布尔表达式都不为true执行代码
   }
   ```

4. ```java
   switch(expression){
       case value :
          //语句
          break; //可选
       case value :
          //语句
          break; //可选
       //你可以有任意数量的case语句
       default : //可选
          //语句
   }
   ```

   > - switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。
   > - switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。
   > - case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。
   > - 当表达式的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。
   > - 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。
   > - switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。
   > - switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。



##	循环结构

1. ```java
   while( 布尔表达式 ) {
     //while循环
     //循环内容
   }
   ```
   
2. ```java
   do {
          //do-while循环
          //代码语句
   }while(布尔表达式);
   ```
   
   > do…while 循环至少会执行一次
   
3. ```java
   for(初始化; 布尔表达式; 更新) {
       //for循环
       //代码语句
   }
   ```
   
   > - 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。
   > - 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。
   > - 执行一次循环后，更新循环控制变量。
   > - 再次检测布尔表达式。循环执行上面的过程。
   
4. ```java
   for(声明语句 : 表达式)
   {
      //For-Each循环
      //代码句子
   }
   
   eg:
   public class TestArray {
      public static void main(String[] args) {
         double[] myList = {1.9, 2.9, 3.4, 3.5};
    
         // 打印所有数组元素
         for (double element: myList) {
            System.out.println(element);
         }
      }
   }
   ```
   
   > 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。
   >
   > 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。
   >
   > 类似于Python中的in关键字
   
5. break语句

   1. 直接执行break语句，跳出当前循环体
   2. 使用带标签的break语句，跳出指定的循环体或带标签的语句块

6. continue语句

   1. 直接执行continue语句，终止执行当前的迭代，不跳出当前循环体，开始下一次的迭代
   2. 使用带标签的continue语句，跳出指定的迭代，开始下一次的迭代



#	对象和类

> - **对象**：一个抽象概念，表示任意存在的事物，通常将对象划分为静态部分和动态部分。静态部分被称为"属性"，任何对象都有自身属性；动态部分被称为"行为"，即对象执行的动作，属于某个类的具体对象称为该类的一个实例，实例是一个具体概念
> - **类**：类是封装对象的属性和行为的载体，即具有相似特征和行为的一类实体被称为类，是一组相关属性和行为的集合

每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。

在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。



##	导入包

```java
import package
```

对于和当前类属于同一个包的情况，可以省略导包语句不写



##	类的定义

类的定义包括两个部分：类声明和类体的定义

1. 类声明

   ```java
   [public] [abstract|final] class ClassName [extends SuperClass] [implements InterfaceNameList]{
       //1.成员变量的声明
       //2.构造方法的定义
       //2.成员方法的定义
   }
   ```

   > 1. 类的修饰符
   >
   >    类的访问修饰符可以是public或缺省，若类用public修饰，则该类称为公共类，公共类可以被任何包中的类使用；若不加public修饰符，类只能被同一包中其他类使用；若使用abstract修饰符，则该类为抽象类；若使用final修饰符，则该类为最终类
   >
   > 2. extends SuperClass
   >
   >    如果一个类要继承某个类需使用extends指明该类的父类，SuperClass为父类名，如果定义类时没有指明所继承的父类则自动继承Object类
   >
   > 3. implements InterfaceNamelist
   >
   >    如果定义的类需要实现接口，则使用implements InterfaceNamelist选项。一个类可以实现多个接口，若实现多个接口，接口名中间用逗号分开
   >
   > 4. 类体
   >
   >    类声明结束后是一对大括号，大括号括起来的部分称为类体(class body)，构造方法用于创建类实例，成员变量定义对象状态，成员方法定义对象行为

2. 类体的定义

   1. 成员变量

      ```java
      [public|protected|private] [static|final] type variableName [=value];
      ```

      > 1. 变量的访问修饰符
      >
      >    [public|protected|private]为变量的访问修饰符，用public修饰的变量为公共变量，公共变量可以被任何方法访问；用protected修饰的变量称为保护变量，保护变量可以被同一个包中的类或子类访问；用private修饰的变量称为私有变量，私有变量只能被同一个类的方法访问；没有使用访问修饰符则该变量只能被同一个包中的类访问
      >
      > 2. 实例变量和静态变量
      >
      >    变量用static修饰则该变量称为静态变量/类变量，否则称为实例变量
      >
      > 3. 使用final修饰的变量叫做最终变量，也称为标识符常量，一旦尾气赋值就不能再改变了

   2. 构造方法

   3. 成员方法



##	创建对象

> 对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。

1. **声明**：声明一个对象，包括对象名称和对象类型。
2. **实例化**：使用关键字 new 来创建一个对象。
3. **初始化**：使用 new 创建对象时，会调用构造方法初始化对象。

```java
类名称 对象名 = new 类名称()
```



##	使用对象

1. 使用成员变量：`对象名.成员变量名`
2. 使用成员方法：`对象名.成员方法名(参数列表)`

# 方法

> Java方法是语句的集合，它们在一起执行一个功能。
>
> - 方法是解决一类问题的步骤的有序组合
> - 方法包含于类或对象中，而不包含在方法中
> - 方法在程序中被创建，在其他地方被引用
>
>  在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。

1. 方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符，即小驼峰。例如：**addPerson**。
2. 下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：`test<MethodUnderTest>_<state>`，例如 `testPop_emptyStack`。
2. 对于一个没有返回值的方法，关键字return可写可不写，如果选择添加return，则return后不能有返回值
2. 一个方法中可以有多个return语句，但是必须保证同时只有一个会被执行到



##	方法的定义

```java
修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
```

> **修饰符：**`[public|protected|private] [static] [abstract|final]`-修饰符是可选的，定义了该方法的访问类型，告诉编译器如何调用该方法。用public修饰的方法可以在任何类中调用；用protected修饰的方法可以在同一个类、同一个包中的类以及子类中调用；用private修饰的方法只能在同一个类中调用；若果缺省访问修饰符，则称包可访问的，即可以被同一个类的方法访问和同一个包中的类访问。用static修饰的方法称为静态方法；用final修饰的方法称为最终方法，最终方法不能被覆盖；用abstract修饰的方法称为抽象方法。
>
> **返回值类型 ：**方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字**void**。
>
> **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名，使用小驼峰命名法 
>
> **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数，这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数，此时不能进行参数的初始化。
>
> **方法体：**方法体包含具体的语句，定义该方法的功能。

1. 方法的定义不能存在嵌套包含关系
2. 不同方法的定义前后顺序不影响使用
2. 方法定义后不会执行，只有调用时才会执行

![](E:\Study Notes\Pictures\方法的定义.jpg)



##	构造方法

1. 构造方法也叫构造器(constructor)，是类的一种特殊方法
2. 当一个对象被创建时候，构造方法用来初始化该对象
3. 构造方法和它所在类的名字相同，但构造方法没有返回值
4. 通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象
5. 不管是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)
6. 一旦你定义了自己的构造方法，默认构造方法就会失效



##	方法的调用

1. 当方法返回一个值的时候，方法调用通常被当做一个值；如果方法返回值是void，方法调用一定是一条语句。
2. 与C语言不同，调用方法时不需要提前声明
3. 调用方法
   1. 单独调用：方法名称(参数)
   2. 打印调用：System.out.println(方法名称(参数))
   3. 赋值调用：数据类型 变量名称 = 方法名称(参数)




## 方法的重载(overload)

1. 一个类的两个方法拥有相同的名字，但是有不同的参数列表(参数个数、参数类型、参数的多类型顺序)
2. Java编译器根据方法签名判断哪个方法应该被调用
3. 方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字
4. 重载的方法必须拥有不同的参数列表，不能仅仅依据修饰符或者返回类型的不同来重载方法，不同的参数名称也不能重载方法





##	可变参数

```java
typeName... parameterName
```

在方法定义中，在指定参数类型后加一个省略号(...) 

一个方法中只能指定一个可变参数，它必须是方法的最后一个参数，任何普通的参数必须在它之前声明。





#	输入输出

##	Scanner类

1. 创建

   ```java
   import java.util.Scanner; 
   
   Scanner s = new Scanner(System.in);
   ```

2. | 变量和类型            | 方法                                              | 描述                                                         |
   | :-------------------- | :------------------------------------------------ | :----------------------------------------------------------- |
   | `void`                | `close()`                                         | 关闭此扫描仪。                                               |
   | `Pattern`             | `delimiter()`                                     | 返回 `Pattern`这 `Scanner`目前用于匹配分隔符。               |
   | `Stream<MatchResult>` | `findAll(String patString)`                       | 返回与提供的模式字符串匹配的匹配结果流。                     |
   | `Stream<MatchResult>` | `findAll(Pattern pattern)`                        | 返回此扫描程序的匹配结果流。                                 |
   | `String`              | `findInLine(String pattern)`                      | 尝试查找从指定字符串构造的下一个模式，忽略分隔符。           |
   | `String`              | `findInLine(Pattern pattern)`                     | 尝试查找指定模式的下一个匹配项，忽略分隔符。                 |
   | `String`              | `findWithinHorizon(String pattern, int horizon)`  | 尝试查找从指定字符串构造的下一个模式，忽略分隔符。           |
   | `String`              | `findWithinHorizon(Pattern pattern, int horizon)` | 尝试查找指定模式的下一个匹配项。                             |
   | `boolean`             | `hasNext()`                                       | 如果此扫描器的输入中有另一个标记，则返回true。               |
   | `boolean`             | `hasNext(String pattern)`                         | 如果下一个标记与从指定字符串构造的模式匹配，则返回true。     |
   | `boolean`             | `hasNext(Pattern pattern)`                        | 如果下一个完整标记与指定模式匹配，则返回true。               |
   | `boolean`             | `hasNextBigDecimal()`                             | 如果此扫描器输入中的下一个标记可以使用 `nextBigDecimal()`方法解释为 `BigDecimal`则返回true。 |
   | `boolean`             | `hasNextBigInteger()`                             | 如果此扫描器输入中的下一个标记可以使用 `nextBigInteger()`方法在默认基数中解释为 `BigInteger` ，则返回true。 |
   | `boolean`             | `hasNextBigInteger(int radix)`                    | 如果此扫描器输入中的下一个标记可以使用 `nextBigInteger()`方法在指定的基数中解释为 `BigInteger` ，则返回true。 |
   | `boolean`             | `hasNextBoolean()`                                | 如果使用从字符串“true \| false”创建的不区分大小写的模式，可以将此扫描器输入中的下一个标记解释为布尔值，则返回true。 |
   | `boolean`             | `hasNextByte()`                                   | 如果使用 [`nextByte()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextByte())方法将此扫描器输入中的下一个标记解释为默认基数中的字节值，则返回true。 |
   | `boolean`             | `hasNextByte(int radix)`                          | 如果使用 [`nextByte()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextByte())方法将此扫描器输入中的下一个标记解释为指定基数中的字节值，则返回true。 |
   | `boolean`             | `hasNextDouble()`                                 | 如果使用 [`nextDouble()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextDouble())方法将此扫描仪输入中的下一个标记解释为double值，则返回true。 |
   | `boolean`             | `hasNextFloat()`                                  | 如果使用 [`nextFloat()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextFloat())方法将此扫描器输入中的下一个标记解释为浮点值，则返回true。 |
   | `boolean`             | `hasNextInt()`                                    | 如果使用 [`nextInt()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextInt())方法将此扫描器输入中的下一个标记解释为默认基数中的int值，则返回true。 |
   | `boolean`             | `hasNextInt(int radix)`                           | 如果此扫描器输入中的下一个标记可以使用 [`nextInt()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextInt())方法解释为指定基数中的int值，则返回true。 |
   | `boolean`             | `hasNextLine()`                                   | 如果此扫描器的输入中有另一行，则返回true。                   |
   | `boolean`             | `hasNextLong()`                                   | 如果使用 [`nextLong()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextLong())方法将此扫描器输入中的下一个标记解释为默认基数中的长值，则返回true。 |
   | `boolean`             | `hasNextLong(int radix)`                          | 如果使用 [`nextLong()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextLong())方法可以将此扫描器输入中的下一个标记解释为指定基数中的长值，则返回true。 |
   | `boolean`             | `hasNextShort()`                                  | 如果使用 [`nextShort()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextShort())方法可以将此扫描器输入中的下一个标记解释为默认基数中的短值，则返回true。 |
   | `boolean`             | `hasNextShort(int radix)`                         | 如果此扫描器输入中的下一个标记可以使用 [`nextShort()`](https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html#nextShort())方法解释为指定基数中的短值，则返回true。 |
   | `IOException`         | `ioException()`                                   | 返回 `IOException`最后通过此抛出 `Scanner`的基本 `Readable` 。 |
   | `Locale`              | `locale()`                                        | 返回此扫描程序的语言环境。                                   |
   | `MatchResult`         | `match()`                                         | 返回此扫描程序执行的上次扫描操作的匹配结果。                 |
   | `String`              | `next()`                                          | 从此扫描仪查找并返回下一个完整令牌。                         |
   | `String`              | `next(String pattern)`                            | 如果它与从指定字符串构造的模式匹配，则返回下一个标记。       |
   | `String`              | `next(Pattern pattern)`                           | 如果匹配指定的模式，则返回下一个标记。                       |
   | `BigDecimal`          | `nextBigDecimal()`                                | 将输入的下一个标记扫描为[`BigDecimal`](https://www.runoob.com/manual/jdk11api/java.base/java/math/BigDecimal.html) 。 |
   | `BigInteger`          | `nextBigInteger()`                                | 将输入的下一个标记扫描为[`BigInteger`](https://www.runoob.com/manual/jdk11api/java.base/java/math/BigInteger.html) 。 |
   | `BigInteger`          | `nextBigInteger(int radix)`                       | 将输入的下一个标记扫描为[`BigInteger`](https://www.runoob.com/manual/jdk11api/java.base/java/math/BigInteger.html) 。 |
   | `boolean`             | `nextBoolean()`                                   | 将输入的下一个标记扫描为布尔值并返回该值。                   |
   | `byte`                | `nextByte()`                                      | 将输入的下一个标记扫描为 `byte` 。                           |
   | `byte`                | `nextByte(int radix)`                             | 将输入的下一个标记扫描为 `byte` 。                           |
   | `double`              | `nextDouble()`                                    | 将输入的下一个标记扫描为 `double` 。                         |
   | `float`               | `nextFloat()`                                     | 将输入的下一个标记扫描为 `float` 。                          |
   | `int`                 | `nextInt()`                                       | 将输入的下一个标记扫描为 `int` 。                            |
   | `int`                 | `nextInt(int radix)`                              | 将输入的下一个标记扫描为 `int` 。                            |
   | `String`              | `nextLine()`                                      | 使此扫描器前进超过当前行并返回跳过的输入。                   |
   | `long`                | `nextLong()`                                      | 将输入的下一个标记扫描为 `long` 。                           |
   | `long`                | `nextLong(int radix)`                             | 将输入的下一个标记扫描为 `long` 。                           |
   | `short`               | `nextShort()`                                     | 将输入的下一个标记扫描为 `short` 。                          |
   | `short`               | `nextShort(int radix)`                            | 将输入的下一个标记扫描为 `short` 。                          |
   | `int`                 | `radix()`                                         | 返回此扫描器的默认基数。                                     |
   | `void`                | `remove()`                                        | `Iterator`的此实现不支持删除操作。                           |
   | `Scanner`             | `reset()`                                         | 重置此扫描仪。                                               |
   | `Scanner`             | `skip(String pattern)`                            | 跳过与指定字符串构造的模式匹配的输入。                       |
   | `Scanner`             | `skip(Pattern pattern)`                           | 跳过与指定模式匹配的输入，忽略分隔符。                       |
   | `Stream<String>`      | `tokens()`                                        | 从此扫描程序返回分隔符分隔的标记流。                         |
   | `String`              | `toString()`                                      | 返回此 `Scanner`的字符串表示 `Scanner` 。                    |
   | `Scanner`             | `useDelimiter(String pattern)`                    | 将此扫描仪的分隔模式设置为从指定的 `String`构造的模式。      |
   | `Scanner`             | `useDelimiter(Pattern pattern)`                   | 将此扫描仪的分隔模式设置为指定的模式。                       |
   | `Scanner`             | `useLocale(Locale locale)`                        | 将此扫描程序的语言环境设置为指定的语言环境。                 |
   | `Scanner`             | `useRadix(int radix)`                             | 将此扫描仪的默认基数设置为指定的基数。                       |

3. next() 与 nextLine() 区别

   next():

   - 一定要读取到有效字符后才可以结束输入。
   - 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。
   - 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。
   - next() 不能得到带有空格的字符串。

   nextLine()：

   - 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。
   - 可以获得空白。

