#	Java

---

#	JRE与JDK

JRE(Java Runtime Environment ) Java运行环境，用来运行JAVA程序的。

JDK(Java Development Kit) Java开发工具包，包含JRE。因此只需要下载安装JDK即可。

JDK是Sun Microsystems针对Java开发员的产品，JSP(Java Server Pages，是由Sun Microsystems公司主导创建的一种动态网页技术标准)需要JDK的支持。

JDK 是整个Java的核心，包括了Java运行环境，Java工具和Java基础的类库。

JDK是Java语言的软件开发工具包(SDK)。SE(J2SE)，standardedition，标准版，是我们通常用的一个版本，从JDK5.0开始，改名为JavaSE。EE(J2EE)，enterpriseedition，企业版，使用这种JDK开发J2EE应用程序，从JDK5.0开始，改名为JavaEE。ME(J2ME)，microedition，主要用于移动设备、嵌入式设备上的java应用程序，从JDK5.0开始，改名为JavaME。

没有JDK的话，无法编译Java程序，如果想只运行Java程序，要确保已安装相应的JRE。



#	JVM

JVM(Java Virtual Machine)，是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

JVM是一种用于计算设备的规范，它是一个虚构出来的机器，是通过在实际的计算机上仿真模拟各种功能实现的。
JVM包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域。
JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在JVM上运行的目标代码（字节码，即.class文件）,就可以在多种平台上不加修改地运行。
JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。

JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。
Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。

JVM执行程序的过程：

1. 加载.class文件
2. 管理并分配内存
3. 执行垃圾收集

JRE（java运行时环境）是由JVM构造的java程序的运行环，也是Java程序运行的环境，但是他同是一个操作系统的一个应用程序一个进程，因此他也有他自己的运行的生命周期，也有自己的代码和数据空间。
JVM在整个jdk中处于最底层，负责于操作系统的交互，用来屏蔽操作系统环境，提供一个完整的Java运行环境。



#	Java特性

Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。

Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等



#	.java文件和.class文件

.java文件是一个文本文件，就是我们用java语言写成的代码。

.class文件是一种二进制文件，即字节码文件，.java文件通过javac(编译器)编译生成的一个文件，可以由JVM装载(类装载)，然后由java(解释器)解释执行。

注意：

1. class文件名和类名保持一致
2. 公共类的类名要和.java文件名保持一致
3. 一个.java文件可以支持多个类，但是最多只能有一个公共类
4. java文件可以创建多个类，有几个类就能编译生成几个.class文件，如果.java文件中的类名出现大小写最后的结果是最后一类的内容。





# IntelliJ IDEA

## 项目结构

> 项目(Project)
>
> > 模块(Module)
> >
> > > 包(Package)
> > >
> > > > 文件(File)



##	.iml文件

IDEA的配置文件

#	基础语法

##	基本语法

1. Java 是**大小写敏感**的
2. **源文件名必须和类名相同**。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 **.java**。（如果文件名和类名不相同则会导致编译错误）
3. 所有的 Java 程序由 **public static void main(String[] args)** 方法开始执行。



## 标识符

1. 类名、变量名以及方法名都被称为标识符
2. 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始
3. 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合
4. **关键字不能用作标识符**
5. 标识符是大小写敏感的
6. 合法标识符举例：age、$salary、_value、__1_value
7. 非法标识符举例：123abc、-salary
8. **命名规范**
   1. 类名规范：首字母大写，后面的每个单词首字母大写(大驼峰式)
   2. 变量名规范：首字母小写，后面的每个单词首字母大写(小驼峰式)
   3. 方法名规范：同变量名



##	修饰符

Java可以使用修饰符来修饰类中方法和属性，通常放在语句的最前端。主要有两类修饰符：

- 访问控制修饰符 : default, public , protected, private
- 非访问控制修饰符 : final, abstract, static, synchronized

1. 访问修饰符
   1. default : 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
   2. private : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。私有访问修饰符是最严格的访问级别，所以被声明为 **private** 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 **private**。
   3. public : 对所有类可见。使用对象：类、接口、变量、方法
   4. protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**
      1. **子类与基类在同一包中**：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；
      2. **子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。
2. 非访问修饰符
   1. static 修饰符，用来修饰类方法和类变量。
   2. final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
   3. abstract 修饰符，用来创建抽象类和抽象方法。
   4. synchronized 和 volatile 修饰符，主要用于线程的编程。



##	关键字

关键字是有特殊含义的、被保留的、完全小写的 、不能随意使用的字符，保留字不能用于常量、变量、和任何标识符的名称。

1. 访问控制

   | 关键字    | 说明     |
   | --------- | -------- |
   | private   | 私有的   |
   | protected | 受保护的 |
   | public    | 公共的   |
   | default   | 默认     |

2. 类、方法和变量修饰符

   | 关键字       | 说明                           |
   | ------------ | ------------------------------ |
   | abstract     | 声明抽象                       |
   | class        | 类                             |
   | extends      | 扩充,继承                      |
   | final        | 最终值,不可改变的              |
   | implements   | 实现（接口）                   |
   | interface    | 接口                           |
   | native       | 本地，原生方法（非 Java 实现） |
   | new          | 新,创建                        |
   | static       | 静态                           |
   | strictfp     | 严格,精准                      |
   | synchronized | 线程,同步                      |
   | transient    | 短暂                           |
   | volatile     | 易失                           |

3. 程序控制语句

   | 关键字     | 说明                       |
   | ---------- | -------------------------- |
   | break      | 跳出循环                   |
   | case       | 定义一个值以供 switch 选择 |
   | continue   | 继续                       |
   | default    | 默认                       |
   | do         | 运行                       |
   | else       | 否则                       |
   | for        | 循环                       |
   | if         | 如果                       |
   | instanceof | 实例                       |
   | return     | 返回                       |
   | switch     | 根据值选择执行             |
   | while      | 循环                       |

4. 错误处理

   | 关键字  | 说明                   |
   | ------- | ---------------------- |
   | assert  | 断言表达式是否为真     |
   | catch   | 捕捉异常               |
   | finally | 有没有异常都执行       |
   | throw   | 抛出一个异常对象       |
   | throws  | 声明一个异常可能被抛出 |
   | try     | 捕获异常               |

5. 包相关

   | 关键字  | 说明 |
   | ------- | ---- |
   | import  | 引入 |
   | package | 包   |

6. 基本类型

   | 关键字  | 说明       |
   | ------- | ---------- |
   | boolean | 布尔型     |
   | byte    | 字节型     |
   | char    | 字符型     |
   | double  | 双精度浮点 |
   | float   | 单精度浮点 |
   | int     | 整型       |
   | long    | 长整型     |
   | short   | 短整型     |

7. 变量引用

   | 关键字 | 说明      |
   | ------ | --------- |
   | super  | 父类,超类 |
   | this   | 本类      |
   | void   | 无返回值  |

8. 保留关键字

   | 关键字 | 说明                 |
   | ------ | -------------------- |
   | goto   | 是关键字，但不能使用 |
   | const  | 是关键字，但不能使用 |



##	运算符

1. 算数运算符

   | 操作符 | 描述                              | 例子               |
   | :----- | :-------------------------------- | :----------------- |
   | +      | 加法 - 相加运算符两侧的值         | A + B 等于 30      |
   | -      | 减法 - 左操作数减去右操作数       | A – B 等于 -10     |
   | *      | 乘法 - 相乘操作符两侧的值         | A * B等于200       |
   | /      | 除法 - 左操作数除以右操作数       | B / A等于2         |
   | ％     | 取余 - 左操作数除以右操作数的余数 | B%A等于0           |
   | ++     | 自增: 操作数的值增加1             | B++ 或 ++B 等于 21 |
   | --     | 自减: 操作数的值减少1             | B-- 或 --B 等于 19 |

2. 关系运算符

   | 运算符 | 描述                                                         | 例子             |
   | :----- | :----------------------------------------------------------- | :--------------- |
   | ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。         | （A == B）为假。 |
   | !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。     | (A != B) 为真。  |
   | >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。   | （A> B）为假。   |
   | <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。   | （A <B）为真。   |
   | >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |
   | <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |

3. 位运算符

   | 操作符 | 描述                                                         | 例子                           |
   | :----- | :----------------------------------------------------------- | :----------------------------- |
   | ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
   | \|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
   | ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
   | 〜     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
   | <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
   | >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
   | >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

4. 逻辑运算符

   | 操作符 | 描述                                                         | 例子                |
   | :----- | :----------------------------------------------------------- | :------------------ |
   | &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。     | （A && B）为假。    |
   | \| \|  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \| \| B）为真。 |
   | ！     | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |

5. 赋值运算符

   | 操作符  | 描述                                                         | 例子                                     |
   | :------ | :----------------------------------------------------------- | :--------------------------------------- |
   | =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |
   | + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |
   | - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |
   | * =     | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |
   | / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |
   | （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |
   | << =    | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |
   | >> =    | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |
   | ＆=     | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |
   | ^ =     | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |
   | \| =    | 按位或赋值操作符                                             | C \| = 2等价于C = C \| 2                 |

6. 条件运算符：`xxx?yyy:zzz`条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

7. instanceof 运算符:该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）

   `( Object reference variable ) instanceof  (class/interface type)`

   如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真

8. 优先级

   | 类别     | 操作符                                     | 关联性   |
   | :------- | :----------------------------------------- | :------- |
   | 后缀     | () [] . (点操作符)                         | 左到右   |
   | 一元     | expr++ expr--                              | 从左到右 |
   | 一元     | ++expr --expr + - ～ ！                    | 从右到左 |
   | 乘性     | * /％                                      | 左到右   |
   | 加性     | + -                                        | 左到右   |
   | 移位     | >> >>>  <<                                 | 左到右   |
   | 关系     | > >= < <=                                  | 左到右   |
   | 相等     | == !=                                      | 左到右   |
   | 按位与   | ＆                                         | 左到右   |
   | 按位异或 | ^                                          | 左到右   |
   | 按位或   | \|                                         | 左到右   |
   | 逻辑与   | &&                                         | 左到右   |
   | 逻辑或   | \| \|                                      | 左到右   |
   | 条件     | ？：                                       | 从右到左 |
   | 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \| = | 从右到左 |
   | 逗号     | ，                                         | 左到右   |



##	注释

```java
//	这是单行注释

/*
这是多行注释
*/
```



#	数据类型

> Java 的两大数据类型:
>
> - 基本数据类型
> - 引用数据类型



##	常量

1. 常量在程序运行时是不能被修改的

2. 在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似

   ```java
   final double PI = 3.1415927;
   ```

3. 虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量

4. 分类

   1. 字符串常量：双引号引起来的部分
   2. 整形常量：直接写上的数字，没有小数点
   3. 浮点数常量：直接写上的数字，有小数点
   4. 字符常量：用单引号引起来的单个字符
   5. 布尔常量：true或false
   6. 空常量：null，代表无任何数据，也无法使用




##	变量

变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间

内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据

**在Java语言中，所有的变量在使用前必须声明**

> 1. 类变量：独立于方法之外的变量，用 static 修饰。
> 2. 实例变量：独立于方法之外的变量，不过没有 static 修饰。
> 3. 局部变量：类的方法中的变量。



###	变量的作用域

1. 变量的范围是程序中该变量可以被引用的部分。
2. 方法内定义的变量被称为局部变量。
3. 局部变量的作用范围从声明开始，直到包含它的块结束。
4. 局部变量必须声明才可以使用。
5. 方法的参数范围涵盖整个方法。参数实际上是一个局部变量。
6. for循环的初始化部分声明的变量，其作用范围在整个循环，但循环体内声明的变量其适用范围是从它声明到循环体结束。
7. 可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量



###	局部变量

1. 局部变量声明在方法、构造方法或者语句块中
2. 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁
3. 访问修饰符不能用于局部变量
4. 局部变量只在声明它的方法、构造方法或者语句块中可见
5. 局部变量是在栈上分配的
6. 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用



###	实例变量

1. 实例变量声明在一个类中，但在方法、构造方法和语句块之外
2. 当一个对象被实例化之后，每个实例变量的值就跟着确定
3. 实例变量在对象创建的时候创建，在对象被销毁的时候销毁
4. 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息
5. 实例变量可以声明在使用前或者使用后
6. 访问修饰符可以修饰实例变量
7. 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见
8. 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定
9. 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName



###	类变量(静态变量)

1. 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外
2. 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝
3. 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变
4. 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量
5. 静态变量在第一次被访问时创建，在程序结束时销毁
6. 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型
7. 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化
8. 静态变量可以通过：*ClassName.VariableName*的方式访问
9. 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致



##	基本数据类型

> Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型
>
> Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的"E+数字"表示E之前的数字要乘以10的多少次方
>
> 当使用字面量的时候，前缀 **0** 表示 8 进制，而前缀 **0x** 代表 16 进制
>
> 数据范围与字节数不一定相关
>
> ```java
> 基本类型：byte 二进制位数：8
> 包装类：java.lang.Byte
> 最小值：Byte.MIN_VALUE=-128
> 最大值：Byte.MAX_VALUE=127
> 
> 基本类型：short 二进制位数：16
> 包装类：java.lang.Short
> 最小值：Short.MIN_VALUE=-32768
> 最大值：Short.MAX_VALUE=32767
> 
> 基本类型：int 二进制位数：32
> 包装类：java.lang.Integer
> 最小值：Integer.MIN_VALUE=-2147483648
> 最大值：Integer.MAX_VALUE=2147483647
> 
> 基本类型：long 二进制位数：64
> 包装类：java.lang.Long
> 最小值：Long.MIN_VALUE=-9223372036854775808
> 最大值：Long.MAX_VALUE=9223372036854775807
> 
> 基本类型：float 二进制位数：32
> 包装类：java.lang.Float
> 最小值：Float.MIN_VALUE=1.4E-45
> 最大值：Float.MAX_VALUE=3.4028235E38
> 
> 基本类型：double 二进制位数：64
> 包装类：java.lang.Double
> 最小值：Double.MIN_VALUE=4.9E-324
> 最大值：Double.MAX_VALUE=1.7976931348623157E308
> 
> 基本类型：char 二进制位数：16
> 包装类：java.lang.Character
> 最小值：Character.MIN_VALUE=0
> 最大值：Character.MAX_VALUE=65535
> ```



###	byte

1. byte 数据类型是8位、有符号的，以二进制补码表示的整数
2. 最小值是 **-128（-2^7）**，最大值是 **127（2^7-1）**
3. 默认值是 **0**
4. byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一



###	**short**

1. short 数据类型是 16 位、有符号的以二进制补码表示的整数
2. 最小值是 **-32768（-2^15）**，最大值是 **32767（2^15 - 1）**
3. Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一
4. 默认值是 **0**



###	**int**

1. int 数据类型是32位、有符号的以二进制补码表示的整数
2. 最小值是 **-2,147,483,648（-2^31）**，最大值是 **2,147,483,647（2^31 - 1）**
3. 一般地整型变量默认为 int 类型
4. 默认值是 **0** 



###	**long**

1. long 数据类型是 64 位、有符号的以二进制补码表示的整数
2. 最小值是 **-9,223,372,036,854,775,808（-2^63）**，最大值是 **9,223,372,036,854,775,807（2^63 -1）**；
3. 这种类型主要使用在需要比较大整数的系统上
4. 默认值是 **0L**
5. 例子： **long a = 100000L**，**long b = -200000L**。
   "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写



###	**float**

1. float 数据类型是单精度、32位、符合IEEE 754标准的浮点数
2. float 在储存大型浮点数组的时候可节省内存空间
3. 默认值是 **0.0f**
4. 浮点数不能用来表示精确的值，如货币
5. 例子：float f1 = 234.5f



###	**double**

1. double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数

2. 浮点数的默认类型为 double 类型

3. double类型同样不能表示精确的值，如货币

4. 默认值是 **0.0d**

5. 例子：

   ```java
   double   d1  = 7D 
   double   d2  = 7.
   double   d3  =  8.0
   double   d4  =  8.D
   double   d5  =  12.9867
   ```



###	 **boolean**

1. boolean数据类型表示一位的信息
2. 只有两个取值：true 和 false
3. 这种类型只作为一种标志来记录 true/false 情况
4. 默认值是 **false**



###	**char**

1. char 类型是一个单一的 16 位 Unicode 字符

2. 最小值是 **\u0000**（十进制等效值为 0），最大值是 **\uffff**（即为 65535）

3. char 数据类型可以储存任何字符

4. char允许输入单个汉字

   

##	引用数据类型

1. 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。
2. 字符串、对象、数组、接口、lambda都是引用数据类型。
3. 所有引用类型的默认值都是null。
4. 一个引用变量可以用来引用任何与之兼容的类型。
5. 例子：Site site = new Site("Runoob")。



###	数组

1. Java 语言中提供的数组是只能存储固定大小的同类型元素
2. 数组的长度在程序运行期间不可改变



####	声明数组

```java
dataType[] arrayRefVar;   // 首选的方法
 
 
dataType arrayRefVar[];  // 效果相同，但不是首选方法
```

1. 必须声明数组变量，才能在程序中使用数组
2. `dataType arrayRefVar[]` 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言



####	创建数组

```java
arrayRefVar = new dataType[arraySize];
```

1. 上面的语法语句做了两件事：

   1. 使用 dataType[arraySize] 创建了一个数组。
   2. 把新创建的数组的引用赋值给变量 arrayRefVar。

2. 数组变量的声明，和创建数组可以用一条语句完成

   ```java
   dataType[] arrayRefVar = new dataType[arraySize];
   ```

3. 可以在创建数组的同时为数组中的元素赋值

   ```java
   dataType[] arrayRefVar = {value0, value1, ..., valuek};
   ```

   



##	类型转换

###	自动类型转换

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

```java
低  ------------------------------------>  高

byte,short,char —> int —> long —> float —> double 
```

- 不能对boolean类型进行类型转换
- 不能把对象类型转换成不相关类的对象
- **在把容量大的类型转换为容量小的类型时必须使用强制类型转换**
- 转换过程中可能导致溢出或损失精度
- 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入
- **必须满足转换前的数据类型的位数要低于转换后的数据类型**



###	强制类型转换

```java
(type) value
```

1. 数据类型必须是兼容的

2. 隐含强制类型转换：

   -  整数的默认类型是 int
   - 小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f
   - byte/short/char类型在运算时，都会首先被提升为int类型再进行运算
   - 对byte/short/char类型赋值时，如果右侧赋值的数据未超过这三种类型的最大范围，javac编译器会自动强制转换为byte/short/char类型

#	对象和类

> - **对象**：一个抽象概念，表示任意存在的事物，通常将对象划分为静态部分和动态部分。静态部分被称为"属性"，任何对象都有自身属性；动态部分被称为"行为"，即对象执行的动作
> - **类**：类是封装对象的属性和行为的载体，即具有相同属性和行为的一类实体被称为类
>
> 类是一种抽象概念，对象是类的实例

每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。

在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。



##	创建对象

> 对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。

1. **声明**：声明一个对象，包括对象名称和对象类型。
2. **实例化**：使用关键字 new 来创建一个对象。
3. **初始化**：使用 new 创建对象时，会调用构造方法初始化对象。



# 源文件声明规则

当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则：

1. 一个源文件中只能有一个 public 类
2. 一个源文件可以有多个非 public 类
3. 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。
4. 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。
5. 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。
7. import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。





# 流程

##	选择结构

1. ```java
   if(布尔表达式)
   {
      //如果布尔表达式为true将执行的语句
   }
   ```

2. ```java
   if(布尔表达式){
      //如果布尔表达式的值为true
   }else{
      //如果布尔表达式的值为false
   }
   ```

3. ```java
   if(布尔表达式 1){
      //如果布尔表达式 1的值为true执行代码
   }else if(布尔表达式 2){
      //如果布尔表达式 2的值为true执行代码
   }else if(布尔表达式 3){
      //如果布尔表达式 3的值为true执行代码
   }else {
      //如果以上布尔表达式都不为true执行代码
   }
   ```

4. ```java
   switch(expression){
       case value :
          //语句
          break; //可选
       case value :
          //语句
          break; //可选
       //你可以有任意数量的case语句
       default : //可选
          //语句
   }
   ```

   > - switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。
   > - switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。
   > - case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。
   > - 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。
   > - 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。
   > - switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。
   > - switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。



##	循环结构

1. ```java
   while( 布尔表达式 ) {
     //循环内容
   }
   ```

2. ```java
   do {
          //代码语句
   }while(布尔表达式);
   ```

   > do…while 循环至少会执行一次

3. ```java
   for(初始化; 布尔表达式; 更新) {
       //代码语句
   }
   ```

   > - 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。
   > - 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。
   > - 执行一次循环后，更新循环控制变量。
   > - 再次检测布尔表达式。循环执行上面的过程。

4. ```java
   for(声明语句 : 表达式)
   {
      //代码句子
   }
   ```

   > 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。
   >
   > 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。
   >
   > 类似于Python中的in关键字



# 方法

> Java方法是语句的集合，它们在一起执行一个功能。
>
> - 方法是解决一类问题的步骤的有序组合
> - 方法包含于类或对象中，而不包含在方法中
> - 方法在程序中被创建，在其他地方被引用
>
>  在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。

1. 方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符，即小驼峰。例如：**addPerson**。
2. 下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：`test<MethodUnderTest>_<state>`，例如 `testPop_emptyStack`。
2. 对于一个没有返回值的方法，关键字return可写可不写，如果选择添加return，则return后不能有返回值
2. 一个方法中可以有多个return语句，但是必须保证同时只有一个会被执行到



##	方法的定义

```java
修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
```

> **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。
>
> **返回值类型 ：**方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字**void**。
>
> **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名，使用小驼峰命名法 
>
> **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。此时不能进行参数的初始化
>
> **方法体：**方法体包含具体的语句，定义该方法的功能。

1. 方法的定义不能存在嵌套包含关系
2. 不同方法的定义前后顺序不影响使用
2. 方法定义后不会执行，只有调用时才会执行

![](E:\Study Notes\Pictures\方法的定义.jpg)



##	方法的调用

1. 当方法返回一个值的时候，方法调用通常被当做一个值；如果方法返回值是void，方法调用一定是一条语句。
2. 与C语言不同，调用方法时不需要提前声明
3. 调用方法
   1. 单独调用：方法名称(参数)
   2. 打印调用：System.out.println(方法名称(参数))
   3. 赋值调用：数据类型 变量名称 = 方法名称(参数)




## 方法的重载(overload)

1. 一个类的两个方法拥有相同的名字，但是有不同的参数列表(参数个数、参数类型、参数的多类型顺序)
2. Java编译器根据方法签名判断哪个方法应该被调用
3. 方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字
4. 重载的方法必须拥有不同的参数列表，不能仅仅依据修饰符或者返回类型的不同来重载方法，不同的参数名称也不能重载方法



##	构造方法

1. 当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值
2. 通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象
3. 不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)
4. 一旦你定义了自己的构造方法，默认构造方法就会失效



##	可变参数

```java
typeName... parameterName
```

在方法定义中，在指定参数类型后加一个省略号(...) 

一个方法中只能指定一个可变参数，它必须是方法的最后一个参数，任何普通的参数必须在它之前声明。
