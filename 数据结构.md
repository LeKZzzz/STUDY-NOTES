#	数据结构

---

> 数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成，即设计数据以何种方式**组织**(逻辑层面)并**存储**(物理层面)在计算机中

1. 逻辑结构
   - 集合
   - 线性结构
   - 非线性结构
      - 树结构
      - 图结构
2. 存储结构
   - 顺序存储
   - 链式存储
3. 抽象数据类型(需要通过固有数据类型实现)
   1. 数据对象
   2. 数据关系
   3. 基本操作



#	线性结构

> 数据结构中的元素存在一对一的相互关系



##	顺序表

```c++
#include <stdio.h>
#include <stdlib.h>

#define ElemType int
#define Status int
#define OK 1
#define ERROR 0
#define InitSize 100

//顺序表


typedef struct SqList {
    ElemType *elem;
    int length;
    int listsize;
};

Status init(SqList &L) {
    ElemType *h;
    h = (ElemType *) malloc(InitSize * sizeof(ElemType));
    L.elem = h;
    L.length = 0;
    L.listsize = InitSize;
    return OK;
}

Status insert(SqList &L, int i, ElemType data) {
    ElemType *p;
    int j;
    if (L.length == L.listsize) {
        L.elem = (ElemType *) realloc(L.elem, sizeof(ElemType));
        L.listsize += 1;
    }
    p = L.elem;
    for (j = L.length; j > i; j--) {
        *(p + j) = *(p + j - 1);
    }
    *(p + j) = data;
    L.length += 1;
    return OK;
}

Status del(SqList &L, int i) {
    ElemType *p;
    p = L.elem;
    for (i -= 1; i < L.length - 1; i++) {
        *(p + i) = *(p + i + 1);
    }
    L.length -= 1;
    return OK;
}

Status display(SqList &L) {
    int i;
    ElemType *p;
    p = L.elem;
    for (i = 0; i < L.length; i++) {
        printf("%d ", *(p + i));
    }
    printf("\n");
    return OK;
}

int main() {
    struct SqList L;
    int i, j;
    ElemType data;

    Status init(SqList &L);
    Status insert(SqList &L, int i, ElemType data);
    Status del(SqList &L, int i);
    Status display(SqList &L);

    init(L);

    printf("输入要初始化的元素个数\n");
    scanf("%d", &i);
    for (j = 1; j <= i; j++) {
        scanf("%d", &data);
        insert(L, j, data);
    }
    display(L);

    printf("输入要插入的元素\n");
    scanf("%d", &data);
    printf("输入要插入的元素位置\n");
    scanf("%d", &i);
    insert(L, i, data);
    display(L);

    printf("输入要删除的元素位置\n");
    scanf("%d", &i);
    del(L, i);
    display(L);
    
    return 0;
}
```



##	链表

1. 链表是由一系列节点组成的元素集合
2. 每个节点包含两部分：数据域item和指向下一个节点的指针next

```c++
#include <stdio.h>
#include <stdlib.h>

#define Status int
#define ElemType int
#define OK 1
#define ERROR 0

//单链表

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} *LinkList;

Status init(LinkList &L, int i, ElemType *elem) {
    int j;
    LNode *p, *q;

    L = (LNode *) malloc(sizeof(LNode));
    L->next = NULL;
    p = L;
    for (j = 0; j < i; j++) {
        q = (LNode *) malloc(sizeof(LNode));
        q->data = elem[j];
        q->next = NULL;
        p->next = q;
        p = p->next;
    }
    return OK;
}

Status display(LinkList &L) {
    LNode *p;
    p = L->next;
    while (p) {
        printf("%d ", p->data);
        p = p->next;
    }
    return OK;
}

Status insert(LinkList &L, int i, ElemType data) {
    LNode *p, *q;
    p = L->next;
    for (int j = 1; j < i - 1; ++j) {
        p = p->next;
    }
    q = (LNode *) malloc(sizeof(LNode));
    q->data = data;
    q->next = p->next;
    p->next = q;
    return 0;
}

Status del(LinkList &L, int i) {
    LNode *p, *q;
    p = L->next;
    for (int j = 1; j < i - 1; ++j) {
        p = p->next;
    }
    q = p->next;
    p->next = p->next->next;
    free(q);

    return 0;
}

int main() {
    ElemType *elem, data;
    int n, j;
    LinkList L;

    scanf("%d", &n);
    elem = (ElemType *) malloc(sizeof(ElemType) * n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &elem[i]);
    }
    init(L, n, elem);
    display(L);

    printf("\n输入要插入的元素\n");
    scanf("%d", &data);
    printf("输入要插入的元素位置\n");
    scanf("%d", &j);
    insert(L, j, data);
    display(L);

    printf("\n输入要删除的元素位置\n");
    scanf("%d", &j);
    del(L, j);
    display(L);

    return 0;
}
```





##	栈(stack)

1. 栈是一个数据集合，可以理解为只能在一端进行插入或删除操作的数组
2. 栈的特点：后进先出 LIFO(lasst-in，first-out)
3. 基本操作：
   1. 进栈(压栈)：push
   2. 出栈：pop
   3. 取栈顶：gettop
4. 应用：括号匹配问题



![栈](E:\Study Notes\Pictures\栈)



##	队列(queue)

1. 队列是一个数据集合，仅允许在数组的一端进行插入，在另一端进行删除
2. 队列的特点：先进先出，FIFO(first-in，first out)
3. 进行插入的一端称为队尾(rear)，插入动作称为进队或入队
4. 进行删除的一端称为对头(front)，删除动作称为出队
5. 实现方式：环形队列，双向队列

![](E:\Study Notes\Pictures\队列)

![](E:\Study Notes\Pictures\环形队列)





##	哈希表(散列表)

1. 哈希表是一个通过哈希函数来计算数据存储位置的数据结构，哈希表由一个直接寻址表和一个哈希函数组成，哈希函数h(k)将元素关键字k作为自变量，返回元素的存储下标
2. 基础操作：
   1. insert(key,value)：插入键值对
   2. get(key)：如果存在键为key的键值对则返回其value，否则返回空值
   3. delete(key)：删除键为key的键值对
3. 哈希冲突：由于哈希表的大小是有限的，而要存储的值的总数量是无限的，因此对于任何哈希函数都会出现两个不同元素映射到同一个位置上的情况，这种情况叫做哈希冲突
4. 解决哈希冲突的方法：
   1. 开放寻址法：如果哈希函数返回的位置已经有值，则可以向后探查新的位置来存储这个值
      1. 线性探查：如果位置i被占用，则探查i+1，i+2，...
      2. 二次探查：如果位置i被占用，则探查i+1^2^，i-1^2^，i+2^2^，i-2^2^，...
      3. 二度哈希：有n个哈希函数，当使用第1个哈希函数h1发生冲突时，尝试使用h2，h3，...
   2. 拉链法：哈希表的每个位置都连接一个链表，当冲突发生时将冲突的元素加到该位置的链表后面
5. 常见哈希函数
   1. 除法哈希法
   2. 乘法哈希法
   3. 全域哈希法 
6. 哈希表的应用：md5算法、SHA2算法



#	树形结构

> 数据结构中的元素存在一对多的相互关系

1. 树是一种可以递归定义的数据结构
2. 树是由n个结点组成的集合
   1. 如果n=0，那这是一棵空树
   2. 如果n>0，那存在1个结点作为树的根结点，其他结点可以分为m个集合，每个集合本身又是一棵树



##	二叉树

1. 存储方式：
   1. 顺序存储：使用数组/列表，第i个结点的子结点为2i+1/2i+2
   2. 链式存储：将二叉树的结点定义为一个对象，结点之间通过类似链表的链接方式来连接 





# 图状结构

> 数据结构中的元素存在多对多的相互关系