#	算法

---

##	排序

###	冒泡排序

```python
def sort(list):
    for i in range(len(list) - 1):
        for j in range(i + 1, len(list)):
            if list[i] < list[j]:
                t = list[i]
                list[i] = list[j]
                list[j] = t
```



###	选择排序

```python
def sort(list):
    for i in range(len(list) - 1):
        min = i
        for j in range(i + 1, len(list)):
            if list[j] < list[min]:
                min = j
        t = list[i]
        list[i] = list[min]
        list[min] = t
```



###	插入排序

```python
def sort(list):
    for i in range(1, len(list)):
        for j in range(i - 1, -1, -1):
            if list[j] > list[j + 1]:
                t = list[j]
                list[j] = list[j + 1]
                list[j + 1] = t
```



###	快速排序

- 右基准

```python
def sort(list, left, right):
    if left >= right:
        return

    mid = right
    tmp = list[mid]
    leftpoint = left
    rightpoint = right
    while leftpoint != rightpoint:
        while list[leftpoint] <= tmp and leftpoint < rightpoint:
            leftpoint += 1
        if leftpoint != rightpoint:
                list[rightpoint] = list[leftpoint]
                rightpoint -= 1
        while list[rightpoint] >= tmp and leftpoint < rightpoint:
            rightpoint -= 1
        if leftpoint != rightpoint:
                list[leftpoint] = list[rightpoint]
                leftpoint += 1
    list[leftpoint] = tmp
    print(list)
    sort(list, rightpoint + 1, right)
    sort(list, left, leftpoint - 1)
```

- 随机基数(双指针交换法)

   ```python
   import random
   
   
   def sort(list, left, right):
       if left >= right:
           return
   
       mid = random.randint(left, right)
       tmp = list[mid]
       leftpoint = left
       rightpoint = right
       while leftpoint < rightpoint:
           while list[leftpoint] < tmp and leftpoint < rightpoint:
               leftpoint += 1
           while list[rightpoint] > tmp and leftpoint < rightpoint:
               rightpoint -= 1
           list[leftpoint], list[rightpoint] = list[rightpoint], list[leftpoint]
           if list[leftpoint] == list[rightpoint] == tmp:
               leftpoint += 1
       sort(list, rightpoint + 1, right)
       sort(list, left, leftpoint - 1)
   ```
   

###	归并排序

![](E:\Study Notes\Pictures\merge_sort.png)

```python
def merge(list, start, mid, end):
    i = start
    j = mid + 1
    tmp = []
    while i <= mid and j <= end:  # 当两个子序列其中一个触碰到自身边界时退出
        if list[i] < list[j]:
            tmp.append(list[i])
            i += 1
        else:
            tmp.append(list[j])
            j += 1
    #   将剩余的有序部分依次添加到tmp数组中存储
    while i <= mid:
        tmp.append(list[i])
        i += 1
    while j <= end:
        tmp.append(list[j])
        j += 1
    list[start:end + 1] = tmp  # 将tmp列表覆盖原列表


def sort(list, start, end):
    if start < end:  # 当传入的子序列元素数为1时即退出递归
        mid = (start + end) // 2
        # 递归分割该序列，直至符合递归退出条件
        sort(list, start, mid)
        sort(list, mid + 1, end)
        merge(list, start, mid, end)  # 下层递归返回即说明返回的为相邻的两个有序子序列，对这两个子序列进行归并
    else:
        return
```



###	堆排序

> 堆排序使用堆的向下调整性质，分为创建堆和依次出数两个步骤，适用于完全二叉树
>
> 向下调整性质即堆顶元素向堆底方向寻找适合它的位置，使整个堆成为大根堆或小根堆

```python
def sift(list, start, end):  # 向下调整函数，start为堆顶，end为堆的最后一个元素的位置
    i = start
    j = 2 * i + 1
    tmp = list[start]
    while j <= end:
        if j + 1 <= end and list[j] < list[j + 1]:  # 比较根节点的两个子结点，最大的子结点和根结点之间进行比较
            j = j + 1
        if tmp < list[j]:   # 比较子结点与根结点大小，如果子结点比根节点大，则子结点上移一层
            list[i]= list[j]
            i = j
            j = 2 * i + 1
        else:
            list[i] = tmp   # 若子结点均比根结点小，则说明根结点已找到它的位置
            break
    else:
        list[i] = tmp   # 根结点位于叶子结点，则该位置为根结点所应处的位置


def heap(list):
    n = len(list) - 1   # 完全二叉树最下一层的最右端的叶子结点
    #   构建堆
    for i in range((n - 1) // 2, -1, -1):   # 从最小的堆开始构建，i为每个根结点的索引
        sift(list, i, n)
    #   依次出数
    for j in range(n, -1, -1):  # 将最后一个元素与首元素交换位置，堆底end往前进1，向下调整新的堆，重复此操作最终成为一个有序列表
        list[0], list[j] = list[j], list[0]
        sift(list, 0, j-1)
```



###	希尔排序

> 希尔排序基于插入排序，希尔排序每次并不使某些元素有序，而是使整体数据越来越接近有序，最后一次排序使所有数据有序

```python
def insert_sort(list, gap):  # gap为步长
    for i in range(gap, len(list)):
        for j in range(i - gap, -1, -gap):
            if list[j] > list[j + gap]:
                t = list[j]
                list[j] = list[j + gap]
                list[j + gap] = t


def shell_sort(list):
    gap = len(list) // 2
    while gap >= 1:
        insert_sort(list, gap)
        gap = gap // 2
```



###	计数排序

> 需要已知待排序数据范围



###	桶排序

> 桶排序的表现取决于数据的分布，可改变桶排序的方法进行优化

```python
def bucket_sort(list, max_num=10000, n=100):  # max_num为数据最大范围，n为桶数
    tmp = [[] for _ in range(n)]  # 建立桶
    for i in list:
        j = min(i // (max_num // n), n - 1)  # 确定数据i应在编号为j的桶，max_num//n为单个桶存储的数据范围，超过最大数据范围的放入最后一个桶
        tmp[j].append(i)  # 将数据存入桶中
        for t in range(len(tmp[j]) - 1, 0, -1):  # 对桶中进行排序
            if tmp[j][t] < tmp[j][t - 1]:
                tmp[j][t], tmp[j][t - 1] = tmp[j][t - 1], tmp[j][t]
            else:
                break
    list.clear()
    for i in range(n):
        list.extend(tmp[i])  # 将tmp中的数据覆盖原列表
```





###	基数排序

> 运用多要素排序的思想，在数据范围不是极其大的情况下有非常快的排序速度，时间复杂度为kn

```python
def radix_sort(list):
    i = 0
    max_num = max(list)  # 通过最大元素确定需要获取基数的次数
    while 10 ** i <= max_num:
        tmp = [[] for _ in range(10)]
        for val in list:
            j = (val // (10 ** i)) % 10  # 根据val的基数放入对应的桶
            tmp[j].append(val)
        list.clear()
        for val in tmp:
            list.extend(val)  # 将桶中数据按照顺序覆盖原列表
        i += 1
```



##	查找

###	二分查找





##	链表





