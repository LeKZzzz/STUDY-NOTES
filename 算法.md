#	算法

---

##	时间复杂度





##	空间复杂度





##	排序

###	冒泡排序

```python
def sort(list):
    for i in range(len(list) - 1):
        for j in range(i + 1, len(list)):
            if list[i] < list[j]:
                t = list[i]
                list[i] = list[j]
                list[j] = t
```



###	选择排序

```python
def sort(list):
    for i in range(len(list) - 1):
        min = i
        for j in range(i + 1, len(list)):
            if list[j] < list[min]:
                min = j
        t = list[i]
        list[i] = list[min]
        list[min] = t
```



###	插入排序

```python
def sort(list):
    for i in range(1, len(list)):
        for j in range(i - 1, -1, -1):
            if list[j] > list[j + 1]:
                t = list[j]
                list[j] = list[j + 1]
                list[j + 1] = t
```



###	快速排序

- 右基准

```python
def sort(list, left, right):
    if left >= right:
        return

    mid = right
    tmp = list[mid]
    leftpoint = left
    rightpoint = right
    while leftpoint != rightpoint:
        while list[leftpoint] <= tmp and leftpoint < rightpoint:
            leftpoint += 1
        if leftpoint != rightpoint:
                list[rightpoint] = list[leftpoint]
                rightpoint -= 1
        while list[rightpoint] >= tmp and leftpoint < rightpoint:
            rightpoint -= 1
        if leftpoint != rightpoint:
                list[leftpoint] = list[rightpoint]
                leftpoint += 1
    list[leftpoint] = tmp
    print(list)
    sort(list, rightpoint + 1, right)
    sort(list, left, leftpoint - 1)
```

- 随机基数(双指针交换法)

   ```python
   import random
   
   
   def sort(list, left, right):
       if left >= right:
           return
   
       mid = random.randint(left, right)
       tmp = list[mid]
       leftpoint = left
       rightpoint = right
       while leftpoint < rightpoint:
           while list[leftpoint] < tmp and leftpoint < rightpoint:
               leftpoint += 1
           while list[rightpoint] > tmp and leftpoint < rightpoint:
               rightpoint -= 1
           list[leftpoint], list[rightpoint] = list[rightpoint], list[leftpoint]
           if list[leftpoint] == list[rightpoint] == tmp:
               leftpoint += 1
       sort(list, rightpoint + 1, right)
       sort(list, left, leftpoint - 1)
   ```
   

###	归并排序

![](E:\Study Notes\Pictures\merge_sort.png)

```python
def merge(list, start, mid, end):
    i = start
    j = mid + 1
    tmp = []
    while i <= mid and j <= end:  # 当两个子序列其中一个触碰到自身边界时退出
        if list[i] < list[j]:
            tmp.append(list[i])
            i += 1
        else:
            tmp.append(list[j])
            j += 1
    #   将剩余的有序部分依次添加到tmp数组中存储
    while i <= mid:
        tmp.append(list[i])
        i += 1
    while j <= end:
        tmp.append(list[j])
        j += 1
    list[start:end + 1] = tmp  # 将tmp列表覆盖原列表


def sort(list, start, end):
    if start < end:  # 当传入的子序列元素数为1时即退出递归
        mid = (start + end) // 2
        # 递归分割该序列，直至符合递归退出条件
        sort(list, start, mid)
        sort(list, mid + 1, end)
        merge(list, start, mid, end)  # 下层递归返回即说明返回的为相邻的两个有序子序列，对这两个子序列进行归并
    else:
        return
```



###	堆排序

> 堆排序使用堆的向下调整性质，分为创建堆和依次出数两个步骤，适用于完全二叉树
>
> 向下调整性质即堆顶元素向堆底方向寻找适合它的位置，使整个堆成为大根堆或小根堆

```python
def sift(list, start, end):  # 向下调整函数，start为堆顶，end为堆的最后一个元素的位置
    i = start
    j = 2 * i + 1
    tmp = list[start]
    while j <= end:
        if j + 1 <= end and list[j] < list[j + 1]:  # 比较根节点的两个子结点，最大的子结点和根结点之间进行比较
            j = j + 1
        if tmp < list[j]:   # 比较子结点与根结点大小，如果子结点比根节点大，则子结点上移一层
            list[i]= list[j]
            i = j
            j = 2 * i + 1
        else:
            list[i] = tmp   # 若子结点均比根结点小，则说明根结点已找到它的位置
            break
    else:
        list[i] = tmp   # 根结点位于叶子结点，则该位置为根结点所应处的位置


def heap(list):
    n = len(list) - 1   # 完全二叉树最下一层的最右端的叶子结点
    #   构建堆
    for i in range((n - 1) // 2, -1, -1):   # 从最小的堆开始构建，i为每个根结点的索引
        sift(list, i, n)
    #   依次出数
    for j in range(n, -1, -1):  # 将最后一个元素与首元素交换位置，堆底end往前进1，向下调整新的堆，重复此操作最终成为一个有序列表
        list[0], list[j] = list[j], list[0]
        sift(list, 0, j-1)
```



###	希尔排序

> 希尔排序基于插入排序，希尔排序每次并不使某些元素有序，而是使整体数据越来越接近有序，最后一次排序使所有数据有序

```python
def insert_sort(list, gap):  # gap为步长
    for i in range(gap, len(list)):
        for j in range(i - gap, -1, -gap):
            if list[j] > list[j + gap]:
                t = list[j]
                list[j] = list[j + gap]
                list[j + gap] = t


def shell_sort(list):
    gap = len(list) // 2
    while gap >= 1:
        insert_sort(list, gap)
        gap = gap // 2
```



###	计数排序

> 需要已知待排序数据范围



###	桶排序

> 桶排序的表现取决于数据的分布，可改变桶排序的方法进行优化

```python
def bucket_sort(list, max_num=10000, n=100):  # max_num为数据最大范围，n为桶数
    tmp = [[] for _ in range(n)]  # 建立桶
    for i in list:
        j = min(i // (max_num // n), n - 1)  # 确定数据i应在编号为j的桶，max_num//n为单个桶存储的数据范围，超过最大数据范围的放入最后一个桶
        tmp[j].append(i)  # 将数据存入桶中
        for t in range(len(tmp[j]) - 1, 0, -1):  # 对桶中进行排序
            if tmp[j][t] < tmp[j][t - 1]:
                tmp[j][t], tmp[j][t - 1] = tmp[j][t - 1], tmp[j][t]
            else:
                break
    list.clear()
    for i in range(n):
        list.extend(tmp[i])  # 将tmp中的数据覆盖原列表
```





###	基数排序

> 运用多要素排序的思想，在数据范围不是极其大的情况下有非常快的排序速度，时间复杂度为kn

```python
def radix_sort(list):
    i = 0
    max_num = max(list)  # 通过最大元素确定需要获取基数的次数
    while 10 ** i <= max_num:
        tmp = [[] for _ in range(10)]
        for val in list:
            j = (val // (10 ** i)) % 10  # 根据val的基数放入对应的桶
            tmp[j].append(val)
        list.clear()
        for val in tmp:
            list.extend(val)  # 将桶中数据按照顺序覆盖原列表
        i += 1
```



##	栈

###	基础功能

```python
class stack:
    def __init__(self):
        self.stack = []

    def push(self, element):  # 压栈
        self.stack.append(element)

    def pop(self):  # 出栈
        self.stack.pop()

    def gettop(self):  # 取栈顶
        if not self.is_empty():
            return self.stack[-1]
        else:
            return None

    def is_empty(self):
        lenth = len(self.stack)
        if lenth > 0:
            return 0
        else:
            return 1
```



###	括号匹配问题

```python
def brace_match(s):
    stack = basic.stack()
    match = {')': '(', ']': '[', '}': '{'}
    for ch in s:
        if ch in {'(', '[', '{'}:
            stack.push(ch)
        else:
            if stack.is_empty():
                return False
            elif match[ch] == stack.gettop():
                stack.pop()
            else:
                return False
    if stack.is_empty():
        return True
    else:
        return False
```



###	深度优先搜索

####	迷宫问题



```python
# 建立迷宫
maze = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]

# 设置下一步的方向
dirs = [
    lambda x, y: (x - 1, y),  # 向上进一步
    lambda x, y: (x + 1, y),  # 向下进一步
    lambda x, y: (x, y - 1),  # 向左进一步
    lambda x, y: (x, y + 1)   # 向右进一步
]


def maze_path(x1, y1, x2, y2):  # x1 y1为起点坐标，x2 y2为终点坐标
    stack = []  # 建立栈
    stack.append((x1, y1))  # 添加起点进栈
    while len(stack) > 0:  # 若栈不空，则对栈顶进行操作
        curNode = stack[-1]  # 当前坐标为栈顶
        if curNode[0] == x2 and curNode[1] == y2:  # 如果当前坐标为终点坐标则输出栈(路径)
            for i in stack:
                print(i)
            return True
        for dir in dirs:  # 对栈顶进行下一步的方向进行操作
            nextNode = dir(curNode[0], curNode[1])  # 下一步的方向
            if maze[nextNode[0]][nextNode[1]] == 0:  # 如果下一步在maze中为0，说明这一步可行
                stack.append(nextNode)  # 将可行的下一步坐标加入栈中
                maze[nextNode[0]][nextNode[1]] = 2  # 标记下一步已走过
                break  # 跳出当前循环，开始下一次的方向选择
        else:  # 如果所有方向都是1或2(已走过)
            maze[curNode[0]][curNode[1]] = 2  # 标记当前坐标为2(已走过)
            stack.pop()  # 栈顶出栈，回退一步
    else:  # 如果栈空，则说明无法到达终点
        return False


print(maze_path(1, 1, 8, 8))
```







##	队列

###	基础功能

```python
class queue:
    def __init__(self, size):
        self.queue = [None for _ in range(size)]
        self.rear = 0
        self.front = 0
        self.size = size

    def push(self, element):
        if not self.is_filled():  # 队列满则无法入队
            self.rear = (self.rear + 1) % self.size
            self.queue[self.rear] = element
        else:
            return False

    def pop(self):
        if not self.is_empty():  # 队列空则无法出队
            self.front = (self.front + 1) % self.size
            return self.queue[self.front]
        else:
            return None

    def is_empty(self):
        if self.front == self.rear:
            return 1
        else:
            return 0

    def is_filled(self):
        if (self.rear + 1) % self.size == self.front:
            return 1
        else:
            return 0
```



###	广度优先搜索

#### 迷宫问题

```python
import basic

# 建立迷宫
maze = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]

# 设置下一步的方向
dirs = [
    lambda x, y: (x - 1, y),  # 向上进一步
    lambda x, y: (x + 1, y),  # 向下进一步
    lambda x, y: (x, y - 1),  # 向左进一步
    lambda x, y: (x, y + 1)  # 向右进一步
]


def print_f(path):  # 打印路径
    realpath = []  # 实际路径
    curNode = path[-1]  # 从传入的路径最后一个元素(终点坐标)开始往前找实际路径
    while curNode[2] != -1:  # 如果坐标不是起点坐标，则继续往前查找
        realpath.append((curNode[0], curNode[1]))
        curNode = path[curNode[2]]
    realpath.append((curNode[0], curNode[1]))
    realpath.reverse()  # 将逆序的实际路径反转获得从起点到终点的实际路径
    for i in realpath:  # 打印输出
        print(i)


def maze_path(x1, y1, x2, y2):  # x1 y1为起点坐标，x2 y2为终点坐标
    queue = basic.queue(21)  # 实例化队列
    queue.push((x1, y1, -1))  # 设置起始坐标，将起点入队
    path = []  # 设置路径列表，元素为含有三个数据的元组，第一个元素为路径结点的x坐标，第二个元素为路径结点的y坐标，第三个元素为该路径结点的上一个结点在路径列表path中的索引
    while not queue.is_empty():  # 若队列不为空，则说明仍然可以寻找路径
        curNode = queue.pop()  # 队首出队，作为查找路径的结点
        path.append(curNode)  # 将出队的队首放入路径列表path中
        for dir in dirs:  # 查找curNode的四个方向是否可以前进一步
            nextNode = dir(curNode[0], curNode[1])  # 可前进的下一步的坐标
            if nextNode == (x2, y2):  # 查找到终点，说明有路径可以到达，打印输出
                path.append((x2, y2, len(path) - 1))
                print_f(path)
                return True
            if maze[nextNode[0]][nextNode[1]] == 0:  # 如果下一个结点的坐标可前进
                queue.push((nextNode[0], nextNode[1],
                            len(path) - 1))  # 将该坐标加入队列中作为之后查找的起始结点，len(path)-1为上一个结点在路径列表path中的索引(即列表终点最后一个元素)
                maze[nextNode[0]][nextNode[1]] = 2  # 将该已查找过的坐标进行标记
    else:  # 若队列为空，说明没有路径到达终点
        return False


print(maze_path(1, 1, 8, 8))
```





##	链表

###	基础功能

```python
class Node:
    def __init__(self, item):
        self.item = item
        self.next = None


def create_head_insert(list):  # 头插法创建列表
    head = Node(list[0])
    for item in list[1:]:
        node = Node(item)
        node.next = head
        head = node
    return head


def create_tail_insert(list):  # 尾插法创建列表
    head = Node(list[0])
    tail = head
    for item in list[1:]:
        node = Node(item)
        tail.next = node
        tail = node
    return head


def traverse(head):  # 遍历
    point = head
    while point:
        print(point.item, end=' ')
        point = point.next
    print('\n')


def insert(head, num, item):  # 在num节点后插入数据item
    curNode = head
    for _ in range(num - 1):
        curNode = curNode.next
    nextNode = Node(item)
    nextNode.next = curNode.next
    curNode.next = nextNode


def delete(head, num):  # 删除num节点
    curNode = head
    for _ in range(num - 2):
        curNode = curNode.next
    nextNode = curNode.next
    curNode.next = nextNode.next


linklist = create_tail_insert([i for i in range(11)])
traverse(linklist)
insert(linklist, 5, 100)
traverse(linklist)
delete(linklist, 6)
traverse(linklist)
```



###	双链表

```python
class Node:
    def __init__(self, item):
        self.item = item
        self.prior = None
        self.next = None
```



#	树



##	二叉树

```python
class BiTreeNode:
    def __init__(self, data):
        self.data = data
        self.lchild = None
        self.rchild = None
```



##	构建二叉树

```c
Status CreateBiTree(BiTree &T) {
    char ch;
    scanf("%c", &ch);
    if (ch == '#') T = NULL;
    else {
        T = (BiTNode *) malloc(sizeof(BiTNode));
        T->data = ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
    return OK;
}
```



###	遍历

>  通过前序遍历和中序遍历可以确定二叉树的结构
>
> 层次遍历使用队列实现

```python
def pre_order(root):  # 前序遍历
    if root != None:
        print(root.data, end=',')
        pre_order(root.lchild)
        pre_order(root.rchild)


def in_order(root):  # 中序遍历
    if root != None:
        in_order(root.lchild)
        print(root.data, end=',')
        in_order(root.rchild)


def post_order(root):  # 后序遍历
    if root != None:
        post_order(root.lchild)
        post_order(root.rchild)
        print(root.data)


import Queue.basic


def level_order(root, size):  # 层次遍历
    queue = Queue.basic.queue(size)
    queue.push(root)
    while not queue.is_empty():
        node = queue.pop()
        print(node.data, end=',')
        if node.lchild != None:
            queue.push(node.lchild)
        if node.rchild != None:
            queue.push(node.rchild)
```

```c++
//非递归算法
void PreOrderTraverse(BiTree T, Status (*Visit)(TElemType e)) {
    InitStack(S);
    Push(S, T);
    while (!StackEmpty(S)) {
        while (GetTop(S, p) && p) { //走到左子树的尽头，p限制左孩子，GetTop(S, p)限制右孩子
            Visit(p->data);
            Push(S, p->lchild);
        }
        Pop(S, p);  //空指针出栈
        if (!StackEmpty(S)) {   //右孩子进栈
            Pop(S, p);
            Push(S, p->rchild);
        }
    }
}
```



###	交换左右子树

```c++
#include "stdio.h"
#include "stdlib.h"

#define Status int
#define OK 1
#define ERROR 0
#define INITSIZE 100
#define ElemType char

typedef struct BiTNode {
    ElemType data;
    BiTNode *lchild;
    BiTNode *rchild;
} BiTNode, *BiTree;

Status CreateBiTree(BiTree &T) {
    char ch;
    scanf("%c", &ch);
    if (ch == '#') T = NULL;
    else {
        T = (BiTNode *) malloc(sizeof(BiTNode));
        T->data = ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
    return OK;
}

Status Exchange(BiTree &T) {
    BiTNode *tmp;
    if (T->lchild != NULL && T->rchild != NULL) {
        Exchange(T->lchild);
        Exchange(T->rchild);
    }
    tmp = T->lchild;
    T->lchild = T->rchild;
    T->rchild = tmp;
    return OK;
}

Status PreOrderTraverse(BiTree T) {
    if (T) {
        printf("%c", T->data);
        PreOrderTraverse(T->lchild);
        PreOrderTraverse(T->rchild);
    }
    return OK;
}

Status main() {
    BiTree T;
    CreateBiTree(T);
    Exchange(T);
    PreOrderTraverse(T);
    return OK;
}
```



##	哈夫曼树

```C
#include "stdio.h"
#include "stdlib.h"
#include "string"

#define Status int
#define OK 1
#define ERROR 0
#define LENGTH 200
#define ElemType char

typedef struct HTNode {
    int weight;
    int parent, lchild, rchild;
} HTNode, *HuffmanTree; //动态分配数组存储哈夫曼树

typedef char **HuffmanCode; //动态分配哈夫曼编码表

Status Select(HuffmanTree HT, int n, int &s1, int &s2) {
    int min;
    int i;
    for (i = 1; i <= n; ++i)
        if (HT[i].parent == 0) {
            min = HT[i].weight;
            s1 = s2 = i;
            break;
        }

    for (int j = i; j <= n; ++j)
        if (HT[j].parent == 0 && HT[j].weight < min) {
            min = HT[j].weight;
            s1 = j;
        }

    min = HT[i].weight;
    for (int j = i; j <= n; ++j) {
        if (j == s1) {
            if (s1 == i) {
                for (int t = i + 1; t <= n; ++t)
                    if (HT[t].parent == 0) {
                        min = HT[t].weight;
                        s2 = t;
                        break;
                    }
            }
            continue;
        }
        if (HT[j].parent == 0 && HT[j].weight < min) {
            min = HT[j].weight;
            s2 = j;
        }
    }
    return OK;
}

Status HuffmanEncode(HuffmanTree &HT, HuffmanCode &HC, int *w, int n) {   //w存放n个字符的权值
    int m, s1, s2, start;
    char *cd;
    m = 2 * n - 1;  //哈夫曼树结点个数
    HT = (HTNode *) malloc((m + 1) * sizeof(HTNode));  //动态分配数组存储哈夫曼树
    //数组初始化
    for (int i = 1; i <= n; ++i)
        HT[i] = {*(w + i - 1), 0, 0, 0};
    for (int i = n + 1; i <= m; ++i)
        HT[i] = {0, 0, 0, 0};

    for (int i = n + 1; i <= m; ++i) {  //创建哈夫曼树
        Select(HT, i - 1, s1, s2);
        HT[i].weight = HT[s1].weight + HT[s2].weight;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[s1].parent = i;
        HT[s2].parent = i;
    }
    HC = (char **) malloc((n + 1) * sizeof(char *));    //分配n个字符编码的头指针向量，即指向以字符数组为元素的数组的指针
    cd = (char *) malloc(n * sizeof(char));  //分配求编码的工作空间，即指向一个字符数组的指针
    cd[n - 1] = '\0'; //编码结束符位置
    for (int i = 1; i <= n; ++i) {
        start = n - 2;
        for (int c = i, f = HT[i].parent; f != 0; c = f, f = HT[f].parent) {
            if (HT[f].lchild == c) cd[start--] = '0';
            else cd[start--] = '1';
        }
        HC[i] = (char *) malloc((n - start) * sizeof(char));
        strcpy(HC[i], &cd[start + 1]);
    }
    free(cd);
    return OK;
}

Status HuffmanDecode(HuffmanTree HT, char *str, int n, char *ch) {
    int p1, p2, m;
    m = 2 * n - 1;
    p1 = 0;
    p2 = m;
    while (str[p1] != '\0') {
        if (str[p1] == '0')
            p2 = HT[p2].lchild;
        else
            p2 = HT[p2].rchild;
        if (p2 <= n) {
            printf("%c", ch[p2 - 1]);
            p2 = m;
        }
        p1++;
    }
    return OK;
}


Status main() {
    Status HuffmanEncode(HuffmanTree &HT, HuffmanCode &HC, int *w, int n);
    Status HuffmanDecode(HuffmanTree HT, char *str, int n, char *ch);

    char ch[LENGTH], str[LENGTH];
    HuffmanTree HT;
    HuffmanCode HC;
    int n, *w;

    scanf("%d", &n);
    w = (int *) malloc(n * sizeof(int));
    for (int i = 0; i < n; ++i)
        scanf("%d", &w[i]);
    scanf("%s", ch);
    scanf("%s", str);
    HuffmanEncode(HT, HC, w, n);
    HuffmanDecode(HT, str, n, ch);

    return OK;
}
```





#	图



##	邻接表

```c++
//
// Created by LeK on 2022/10/30.
//
//邻接表

#include "stdlib.h"
#include <iostream>

#define Status int
#define OK 1
#define ERROR 0
#define VertexType char

using namespace std;

typedef struct ArcNode {
    int adjvex; //该弧所指向的顶点的位置
    struct ArcNode *nextarc;    //指向下一条弧的指针
} ArcNode;

typedef struct VNode {
    VertexType data;    //顶点信息
    ArcNode *firstarc;  //指向第一条以该顶点为尾的弧的指针
} VNode, *AdjList;

typedef struct {
    AdjList vertices;   //头结点数组
    int vexnum, arcnum;  //图的当前顶点数和弧数
    int kind;   //图的种类标志
} ALGraph;

Status CreatAdjList(ALGraph &G) {
    int j, t;
    char ch, vj, vt;
    ArcNode *arc, *p;
    G.vertices = (AdjList) calloc(G.vexnum , sizeof(VNode));    //头结点数组
    cout<<"输入顶点序列：";
    for (int i = 0; i < G.vexnum; ++i) {    //顶点数据
        cin>>ch;
        G.vertices[i].data = ch;
    }
    cout<<"输入弧偶对：\n";
    for (int i = 0; i < G.arcnum; ++i) {    //输入弧
        cin>>vj>>vt;
        j = t = 0;
        while (G.vertices[j].data != vj) j++;   //弧尾顶点索引
        while (G.vertices[t].data != vt) t++;   //弧头顶点索引
        p = G.vertices[j].firstarc;
        if (!p) {
            arc = (ArcNode *) malloc(sizeof(ArcNode));
            arc->adjvex = t;
            arc->nextarc = NULL;
            G.vertices[j].firstarc = arc;
        } else {
            while (p->nextarc) p = p->nextarc;
            arc = (ArcNode *) malloc(sizeof(ArcNode));
            arc->adjvex = t;
            arc->nextarc = NULL;
            p->nextarc = arc;
        }
    }
    return OK;
}

Status Display(ALGraph G) {
    ArcNode *p;
    for (int i = 0; i < G.vexnum; ++i) {
        p = G.vertices[i].firstarc;
        if (!p) {
            printf("NULL\n");
        } else {
            while (p) {
                printf("%d ", p->adjvex);
                p = p->nextarc;
            }
            printf("\n");
        }
    }
    return OK;
}

int main() {
    ALGraph G;
    cout<<"输入顶点数和弧数：";
    cin>>G.vexnum>>G.arcnum;
    printf("\n");
    CreatAdjList(G);
    Display(G);
    return 0;
}
```



